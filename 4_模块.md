# 模块

## 模块和包

模块和包是组织和管理代码的重要概念。模块和包帮助组织和管理代码，提供了代码重用和抽象的机制。通过使用模块和包，可以更好地组织和结构化Python代码，并使其更易于维护和扩展。

### 模块介绍

**模块**（Module）是一个包含了函数、变量和类等定义的文件。模块可视为一个工具箱，其中包含了一些功能相关的代码。使用模块可以：

1. 提供代码复用：在多个程序中导入同一个模块来使用其中的函数、变量和类，从而避免重复编写相同的代码。
2. 实现封装和抽象：将一些特定功能相关的代码放在一个模块中，以便于组织和管理。

在Python中，每个以`.py`为扩展名的文件都可以作为一个模块。可以通过`import`语句导入一个模块，并使用模块名加点运算符来访问其中的函数、变量和类。例如：

```python
import math

radius = 5
area = math.pi * math.pow(radius, 2)
print(area)
```

上述代码导入了名为`math`的模块，然后使用`math.pi`和`math.pow`来计算圆的面积。

### 模块分类

1. **内置模块**：标准库中提供了大量的内置模块，可以直接在Python中使用，无需安装额外的包。这些模块包含了各种功能，例如数学运算（`math`）、文件操作（`os`、`io`）、日期和时间处理（`datetime`）等。
2. **第三方模块**：第三方模块是由Python社区以及其他开发者编写和维护的，可以通过工具如`pip`进行安装。这些模块提供了各种额外的功能和工具，例如数据科学（`numpy`、`pandas`）、网络请求（`requests`）、Web框架（`Flask`、`Django`）等。
3. **自定义模块**：自定义模块是用户根据需求编写的模块。它们可以是单个`.py`文件或者位于同一目录下的多个文件构成的包。自定义模块用于组织、封装和复用代码，使代码更具可维护性和可扩展性。
4. **特殊模块**：特殊模块指的是一些特定用途的模块，如`sys`、`time`和`random`等。这些模块提供了访问系统信息、时间处理和随机数生成等功能。

根据模块的分类，可以选择合适的模块来实现特定的功能。内置模块提供了Python基本功能的支持，第三方模块提供了丰富的扩展功能和工具，而自定义模块则可以根据个人或项目的需求进行定制开发。使用不同类型的模块，可以更高效地开发和组织Python代码。

### 包介绍

**包**（Package）是一个包含多个模块的文件夹。它提供了更高级别的代码组织方式。包可以将相关的模块组织到一个目录下，形成一个更大的代码集合。例如，创建一个名为`my_package`的包，其中包含了多个模块文件。包的目录结构可以是这样的：

```shell
my_package/
    __init__.py
    module1.py
    module2.py
```

其中，`__init__.py`是一个空文件，它用来指示此目录是一个Python包。可以使用`import`语句导入整个包或包中的特定模块。例如：

```python
import my_package.module1

my_package.module1.some_function()
```

上述代码导入了名为`my_package.module1`的模块，并调用了其中的`some_function()`函数。

## 自定义模块

### 自定义模块介绍

在Python中，自定义模块是由用户自行创建的模块，用于组织、封装和复用代码。自定义模块可以是一个独立的 `.py` 文件，也可以是一个包（一个包含多个模块文件的文件夹）。
创建和使用自定义模块的一般步骤：

1. **创建模块文件**：创建一个以 `.py` 为扩展名的文件，作为自定义模块的文件。该文件的名称应该描述模块所提供的功能，例如 `my_module.py`。
2. **定义功能**：在模块文件中，编写代码来定义函数、变量、类等功能。这些功能将被其他程序或模块引用和使用。

   ```python
   """my_module.py"""
   def greeting(name):
       print("Hello, " + name)

   def add_numbers(a, b):
       return a + b

   pi = 3.14159
   ```

3. **导入模块**：在需要使用自定义模块的地方，使用 `import` 语句导入模块。模块名就是模块文件的名称（不含 `.py` 扩展名）。

   ```python
   import my_module

   my_module.greeting("Alice")

   result = my_module.add_numbers(3, 5)
   print(result)

   print(my_module.pi)
   ```

4. **使用模块功能**：通过模块名和点运算符，可以访问和调用模块中定义的函数、变量和类。
   注意：如果想要直接使用模块中的函数或变量，而不带模块名，可以使用 `from module_name import function_name` 的形式导入。

自定义模块的优势在于提供了一种组织和复用代码的方式。通过将相关的功能放在一个模块中，可以提高代码的可读性和可维护性，并且可以在不同的程序中重复使用这些功能。
如果需要创建一个包，它可以包含多个模块文件。在包的根目录下，需要添加一个名为 `__init__.py` 的空文件，以标识该目录为一个包。这样，其他程序就可以通过 `import package_name.module_name` 来导入其中的模块。

### 模块检索顺序

当Python尝试导入模块时，它会按照以下规则查找和定位模块：

1. **脚本同目录下的模块**：当在一个脚本中导入模块时，Python会首先在该脚本所在的目录中搜索同名的模块文件。这意味着在脚本中使用 `import module_name`，Python会优先查找并导入与脚本同目录下的 `module_name.py` 模块。
2. **内置模块**：如果脚本同目录下没有找到所需的模块，Python会接着搜索内置模块。内置模块是Python解释器提供的核心功能，无需额外安装。
3. **sys.path**：如果模块既不是脚本同目录下的模块，也不是内置模块，Python会按照 `sys.path` 列表中的路径进行搜索。`sys.path` 是一个包含目录路径的列表，由以下几个位置组成：
   - 输入脚本的当前目录（即运行脚本的目录）
   - 环境变量 PYTHONPATH 中列出的目录
   - 默认安装的 Python 库目录

   ```python
   import sys

   for path in sys.path:
      print(path)


   """输出结果：
   PS H:\1_python开发\99\script> python .\test_str.py
   H:\1_python开发\99\script # 脚本目录
   G:\python\python311.zip
   G:\python\DLLs
   G:\python\Lib
   G:\python  # 安装目录
   G:\python\Lib\site-packages # 安装的第三方包存放目录"""
   ```

   在 `sys.path` 中的路径按照它们出现的顺序进行搜索。如果有多个路径中存在同名模块，Python将在第一个匹配到的路径中找到并加载模块。
4. **第三方模块**：如果模块不在以上路径中，Python会尝试在已安装的第三方模块中进行搜索。第三方模块是由Python社区或其他开发者创建的，并通过工具如 `pip` 进行安装。它们通常被安装在Python的 `site-packages` 目录中，而该目录通常包含在 `sys.path` 中。
5. **包**：如果导入的是一个包（一个包含多个模块文件的文件夹），Python会在包所在的目录中查找一个名为 `__init__.py` 的文件。这个文件标志着该目录是一个包。通过 `import package_name` 导入整个包，或者通过 `from package_name import module_name` 导入包中的特定模块。
   - 想导入包中的子模块时，可以在包的 `__init__.py` 文件中使用 `__all__` 变量来指定要导入的模块列表。这样，当导入包时，只有 `__all__` 列表中列出的模块会被导入。

综上所述，Python导入模块时的查找规则是：

1. 脚本同目录下的模块
2. 内置模块
3. sys.path 中指定的路径
4. 第三方模块
5. 包中的模块

### 绝对导入和相对导入

在Python中，模块的导入可以使用绝对导入或相对导入。

#### 绝对导入

**绝对导入**是指从顶级包开始的完整模块路径。它通常用于导入外部包和自定义包中的模块。绝对导入的语法是 `import` 加上模块的完整路径。

例如，有一个名为 `myproject` 的顶级包，其中包含子包 `package1`，并且 `package1` 包中有一个名为 `module1` 的模块。要从另一个模块中使用绝对导入来导入 `module1`，可以这样写：

```python
from myproject.package1 import module1
```

这里的 `myproject` 是顶级包，`package1` 是 `myproject` 下的子包，`module1` 是 `package1` 中的模块。

#### 相对导入

**相对导入**是指从当前模块的相对位置开始的导入。它通常用于在同一个包内导入其他模块。相对导入的语法是 `from .`（表示当前目录）或 `from ..`（表示父级目录），然后跟随模块名。

例如，在上述示例中的 `package1` 包中，如果要从 `module1` 中导入同一包中的另一个模块 `module2`，可以使用相对导入：

```python
from . import module2
```

这里的 `.` 表示当前包目录，也就是 `package1`。

需要注意的是，在不同Python版本中，相对导入的语法可能会有所不同。在Python 3中，使用相对导入时，必须明确指定当前包的名称。例如，使用 `from . import module2` 而不是 `from .module2 import something`。

### 模块中的 `__name__` 变量

在Python中，`__name__` 是一个特殊的内置变量，它可以提供模块的名称或脚本的执行环境。这个变量在不同的上下文中具有不同的含义。

1. **作为模块的名称**：当一个Python文件被作为一个模块导入时，`__name__` 表示该模块的名称。在这种情况下，它的值是字符串类型，并且等于该模块的文件名（不包括扩展名 `.py`）。
   例如，如果有一个名为 `module.py` 的 Python 模块文件，并且在另一个脚本中使用 `import module` 来导入该模块，那么在 `module.py` 中，`__name__` 的值将是 `'module'`。
2. **作为脚本的执行环境**：当一个Python文件直接被执行时（即作为脚本运行），`__name__` 的值是 `'__main__'`。这种情况下，Python会将该文件视为主程序，并从该文件开始执行。
   例如，有一个名为 `script.py` 的 Python 脚本文件，并通过 `python script.py` 命令直接运行它，那么在 `script.py` 中，`__name__` 的值将是 `'__main__'`。

通过使用 `__name__` 变量，可以根据模块是直接执行还是被导入来执行不同的代码逻辑。通常，在一个模块文件中，可以在 `if __name__ == '__main__':` 语句块中编写一些测试代码，它们只会在该模块直接执行时运行。此时，`if __name__ == '__main__':`也就成了主文件的程序入口。

例如：

```python
def function1():
    print("Function 1")

def function2():
    print("Function 2")

if __name__ == '__main__':
    # 在当前模块直接执行时运行下面的代码
    function1()
    function2()
```

在上述代码中，当该模块被导入时，`function1()` 和 `function2()` 不会被执行。但是当该模块作为脚本直接执行时，这两个函数会被调用并输出结果。

## 常见的内置模块

### random

在Python中，random模块是用于生成随机数的内置模块。它提供了多种函数和方法，可以用于随机数的生成、随机序列的操作以及随机选择等。

要使用random模块，首先需要导入它：

```python
import random
```

下面是random模块中常用的几个函数和方法：

1. `random()`: 生成一个[0, 1)范围内的随机浮点数。

   ```python
   num = random.random()
   ```

2. `randrange(start, stop[, step])`: 生成一个指定范围内的随机整数。

   ```python
   num = random.randrange(1, 10)  # 生成1到9之间的随机整数
   ```

3. `uniform(a, b)`: 生成一个指定范围内的随机浮点数。

   ```python
   num = random.uniform(1, 10)  # 生成1到10之间的随机浮点数
   ```

4. `choice(seq)`: 从序列中随机选择一个元素。

   ```python
   item = random.choice([1, 2, 3, 4, 5])  # 从列表中随机选择一个元素
   ```

5. `shuffle(seq)`: 将序列中的元素随机排序。

   ```python
   lst = [1, 2, 3, 4, 5]
   random.shuffle(lst)  # 随机打乱列表顺序
   ```

除了上述函数和方法，random模块还提供了其他一些用于生成随机数的函数，如`randint(a, b)`、`sample(population, k)`等。可以根据具体需求选择合适的函数进行使用。

需要注意的是，随机数的生成基于伪随机算法，也就是说，它们实际上是以某种规律生成的，但在大多数情况下都足够随机。如果需要更高质量的随机数，可以考虑使用`random`模块的`random()`函数生成种子，然后使用`random.seed()`函数设置种子。例如：

```python
random.seed(1)  # 设置随机数种子为1
num = random.random()  # 生成使用种子的随机数
```

这样可以使得每次运行程序时生成的随机数序列是相同的。

```python
import random
import string

# 1. 随机整数
v1 = random.randint(10, 20)
print(v1)

# 2. 随机小数
v2 = random.uniform(0, 1)
print(v2)

# 3. 随机选择一个数
v3 = random.choice([11, 22, 33, 44])
print(v3)

# 4. 随机选择2个数
v4 = random.sample([11, 22, 33, 44], 2)
print(v4)

# 5. 打乱顺序
num_list = [1, 99, 23, 12, 55, 111]
random.shuffle(num_list)
print(num_list)

# 6. 随机字母
v6 = random.choice(string.ascii_letters)
print(v6)
```

#### 案例：年会抽奖

```python
import random

# 1. 创建300个员工
user_list = ["用户-{}".format(i) for i in range(1, 301)]

# 2. 奖项和人数
prizes = [
    ("三等奖", 5, "iPad"),
    ("二等奖", 3, "iPhone 14"),
    ("一等奖", 1, "马尔代夫"),
    ("特等奖", 1, "一套房")
]

# 3. 抽奖，抽取指定的数量（一个员工不能重复中奖）
for i in prizes:
    winners = random.sample(user_list, i[1])
    print(winners)
    for j in winners:
        prize_info = "恭喜：{}获得{}，奖品为{}".format(
            j, i[0], i[2])
        user_list.remove(j)
        print(prize_info)

# 方案2
for i in prizes:
    winners = random.sample(user_list, i[1])
    for j in winners:
        user_list.remove(j)
    prize_info = "恭喜：{}获得{}，奖品为{}".format(
        "、".join(winners), i[0], i[2])
    print(prize_info)
```

### hashlib

在Python中，hashlib模块是用于加密相关操作的内置模块。它提供了多种哈希算法，包括常见的MD5、SHA-1、SHA-224、SHA-256、SHA-384和SHA-512等。

要使用hashlib模块，首先需要导入它：

```python
import hashlib
```

下面是hashlib模块中常用的几个函数：

1. `md5()`: 创建一个MD5哈希对象。

   ```python
   m = hashlib.md5()
   ```

2. `sha1()`: 创建一个SHA-1哈希对象。

   ```python
   m = hashlib.sha1()
   ```

3. `sha256()`: 创建一个SHA-256哈希对象。

   ```python
   m = hashlib.sha256()
   ```

4. `update(msg)`: 更新哈希对象的消息。

   ```python
   m.update(b"hello world")  # 更新哈希对象的消息为"hello world"
   ```

5. `hexdigest()`: 返回哈希对象的十六进制表示。

   ```python
   result = m.hexdigest()  # 获取哈希对象的十六进制表示
   ```

除了上述函数，hashlib模块还提供了其他一些用于哈希操作的函数，如`sha224()`、`sha384()`、`sha512()`等。可以根据具体需求选择合适的函数进行使用。

需要注意的是，由于哈希算法的不可逆性，因此无法通过哈希值反推出原始消息。因此，在实际使用中，哈希算法通常用于验证数据的完整性、生成密码等方面。例如，可以将用户输入的密码进行哈希，然后将哈希值保存在数据库中，以保证用户的密码不会被明文存储。

另外，由于哈希算法的计算复杂度相对较高，因此在处理大量数据时需要注意性能问题。如果需要对大量数据进行哈希操作，可以考虑使用多线程或异步编程等方式提高效率。

```python
import hashlib

data = "admin"

obj = hashlib.md5()
obj.update(data.encode('utf-8'))
res = obj.hexdigest()
print(res)
```

#### 加盐

在加密过程中，"加盐"（Salting）是一种增强密码安全性的技术。它将一个随机生成的值（盐）与明文密码结合起来，然后对结合后的字符串进行哈希运算，最终得到加密后的密码。

```python
import hashlib

data = "admin"

# 加盐（弱密码加密后也容易因撞库而破解，加盐后则不再容易破解）
obj = hashlib.md5("asieidnfosnfo".encode('utf-8'))
obj.update(data.encode('utf-8'))
res = obj.hexdigest()
print(res)
```

加盐的工作流程：

1. **生成盐**：首先，系统会生成一个随机的盐值。盐值通常是一个较长的随机字符串，可以通过伪随机数生成器来获得。盐的目的是增加密码的复杂度和随机性，使得相同的密码在经过加盐后生成的哈希值也不同。
2. **结合盐和密码**：将盐与用户提供的密码结合在一起。一种常见的方式是将盐添加到密码的前面或后面，形成一个新的字符串。
3. **计算哈希值**：使用哈希函数（如MD5、SHA-256等）对结合后的字符串进行哈希运算。哈希函数将输入转换为固定长度的哈希值，该值是不可逆且唯一的。
4. **保存盐和哈希值**：将生成的盐值和计算得到的哈希值一起保存在数据库或其他持久化存储中，用于后续验证密码。

验证密码的步骤：

1. **获取盐值和哈希值**：从存储中获取用户的盐值和相应的哈希值。
2. **结合盐和待验证密码**：将存储的盐值与待验证的密码结合在一起。
3. **计算哈希值**：使用相同的哈希函数对结合后的字符串进行哈希运算。
4. **比较哈希值**：将计算得到的哈希值与存储的哈希值进行比较。如果两者相同，则表示密码验证通过；否则，表示密码错误。

通过加盐的方式，即使相同的密码在不同用户间被多次使用，生成的哈希值也不同。这样一来，即使黑客获取到哈希值，也无法直接猜测出原始密码。同时，由于盐值是随机生成且唯一与每个用户相关，即使两个用户使用相同的密码，其加盐后的哈希值也是不同的，提高了密码的安全性。

#### 加盐使用演示1

```python
import hashlib
import os

def hash_password(password, salt=None):
    if salt is None:
        salt = os.urandom(16)  # 生成一个随机的盐值
    else:
        salt = bytes.fromhex(salt)  # 将传入的盐值转换为字节串
    # 结合盐和密码
    salted_password = salt + password.encode()
    # 计算哈希值
    hashed_password = hashlib.sha256(salted_password).hexdigest()
    return salt.hex(), hashed_password

# 示例使用
password = "password123"
salt, hashed_password = hash_password(password)
print("Salt:", salt)
print("Hashed Password:", hashed_password)
```

在上面的代码中，`hash_password()` 函数接受一个明文密码和一个可选的盐值作为输入，并返回最终的盐值和计算得到的哈希值。如果不提供盐值，则会生成一个随机的盐值。

注意，在验证密码时，需要保存生成的盐值以便后续使用。在实际应用中，通常会将盐值和哈希值一起保存在数据库或其他持久化存储中，并在需要验证密码时提取盐值进行验证操作。

#### 加盐使用演示2

```python
import hashlib

# 1. 输入
user = input("用户名：")
pwd = input("密码：")

# 2. 加密密码
obj = hashlib.md5("sdsfioe".encode('utf-8'))
obj.update(pwd.encode('utf-8'))
password = obj.hexdigest()

# 3. 写入文件
with open("a1.txt", mode="a", encoding="utf-8") as f:
    line = "{} | {}\n".format(user, password)
    f.write(line)
```

#### 用户注册-写入文件，用户登录-读取文件

```python
import hashlib

DB_FILE_PATH = "user_info.txt"


def md5(data_string):
    obj = hashlib.md5("sdsfioe".encode('utf-8'))
    obj.update(data_string.encode('utf-8'))
    return obj.hexdigest()


def register():
    # 1. 输入
    user = input("用户名：")
    pwd = input("密码：")
    # 2. 加密密码
    password = md5(pwd)
    # 3. 写入文件
    with open(DB_FILE_PATH, mode="a", encoding="utf-8") as f:
        line = "{}|{}".format(user, password)
        f.write(line+"\n")


def login():
    user = input("用户名：")
    pwd = input("密码：")
    password = md5(pwd)
    is_success = False
    with open(DB_FILE_PATH, mode="r", encoding="utf-8") as f:
        for line in f:
            line = line.strip()
            db_user, db_pwd = line.split("|")
            if db_user == user and db_pwd == password:
                is_success = True
                break
    if is_success:
        print("登录成功！")
    else:
        print("登录失败！")


def run():
    func_dict = {
        "1": register,
        "2": login
    }
    print("1. 注册\n2. 登录")
    choice = input("请选择序号：")
    func = func_dict.get(choice)
    if not func:
        print("没有这个选项，请重新选择！")
    else:
        func()


if __name__ == '__main__':
    run()
```

### JSON

#### JSON基本概念及优点

JSON（JavaScript Object Notation）是一种轻量级的数据交换格式，常用于将数据从一个程序传输到另一个程序。它使用简洁的文本格式来表示结构化的数据，易于阅读和编写，并且可以被多种编程语言解析和生成。本质是一个字符串，有自己特定的格式。

JSON的基本概念：

1. 对象（Object）：由花括号 `{}` 包围，用来表示无序键值对集合。
2. 键值对（Key-Value Pair）：由键和值组成，键和值之间使用冒号 `:` 分隔。
3. 数组（Array）：由方括号 `[]` 包围，用来表示有序值的列表。
4. 值（Value）：可以是字符串、数字、布尔值、对象、数组或者 `null`。

```json
{
"name": "John",
"age": 30,
"city": "New York",
"hobbies": ["reading", "running", "swimming"],
"isStudent": false,
"address": {
   "street": "123 Main St",
   "city": "Seattle"
},
"scores": [
   {"subject": "Math", "score": 90},
   {"subject": "Science", "score": 85}
]
}
```

JSON的优点：

- 简洁、易于阅读和编写。
- 跨语言、跨平台支持，可以方便地在不同的编程语言之间传输数据。
- 支持结构化数据的表示，可以嵌套对象和数组，灵活性高。

#### Python中支持的序列化类型

Python中支持的序列化类型及其对应的JSON类型：

- `dict`（字典）：对应的JSON类型为对象（Object）。
- `list`（列表）：对应的JSON类型为数组（Array）。
- `tuple`（元组）：对应的JSON类型为数组（Array），注意元组在JSON中被表示为一个包含元素的数组。
- `str`（字符串）：对应的JSON类型为字符串（String）。
- `int`、`float`、`bool`（整数、浮点数、布尔值）：对应的JSON类型分别为数字（Number）和布尔值（Boolean）。
- `None`（空值）：对应的JSON类型为null。

注意：在Python中，还可以使用其他第三方库（如`pickle`、`marshal`）来进行对象的序列化，但它们生成的数据格式不是JSON格式。以上提到的JSON类型是指标准的JSON格式。

#### json模块

在Python中，json模块是用于处理JSON数据的内置模块。它提供了多个函数和方法，可以将Python对象转换为JSON格式的字符串，也可以将JSON格式的字符串转换为Python对象。

要使用json模块，首先需要导入它：

```python
import json
```

下面是json模块中常用的几个函数和方法：

1. `dumps(obj, *, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, default=None, sort_keys=False, **kw)`: 将Python对象编码成JSON格式的字符串。

   ```python
   data = {"name": "John", "age": 30, "city": "New York"}
   json_str = json.dumps(data)
   ```

2. `loads(s, *, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, object_pairs_hook=None, **kw)`: 将JSON格式的字符串解码为Python对象。

   ```python
   json_str = '{"name": "John", "age": 30, "city": "New York"}'
   data = json.loads(json_str)
   ```

3. `dump(obj, fp, *, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, default=None, sort_keys=False, **kw)`: 将Python对象编码为JSON格式的字符串，并写入文件。

   ```python
   data = {"name": "John", "age": 30, "city": "New York"}
   with open("data.json", "w") as f:
       json.dump(data, f)
   ```

4. `load(fp, *, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, object_pairs_hook=None, **kw)`: 从文件中读取JSON格式的字符串，并解码为Python对象。

   ```python
   with open("data.json", "r") as f:
       data = json.load(f)
   ```

5. `JSONEncoder`类：用于自定义JSON编码器，可以继承该类并重写其方法来实现自定义的JSON编码器。

   ```python
   class MyEncoder(json.JSONEncoder):
       def default(self, obj):
           if isinstance(obj, datetime.datetime):
               return obj.strftime("%Y-%m-%d %H:%M:%S")
           else:
               return super().default(obj)
   
   data = {"name": "John", "age": 30, "create_time": datetime.datetime.now()}
   json_str = json.dumps(data, cls=MyEncoder)
   ```

除了上述函数和方法，json模块还提供了其他一些用于处理JSON数据的函数和类，如`JSONDecoder`类、`JSONDecodeError`异常等。可以根据具体需求选择合适的函数进行使用。

需要注意的是，在编码和解码JSON数据时，需要确保数据格式正确且符合规范。同时还需要注意处理异常情况，例如JSONDecodeError异常、KeyError异常等。

#### Python对象与JSON数据的转换

在Python中，可以使用内置的`json`模块来解析和生成JSON数据：

1. 序列化：将Python对象转换为JSON字符串：`json.dumps()`

   ```python
   import json

   data = {"name": "John", "age": 30, "hobies": (
      "唱", "跳", "rap", "打篮球"), "is_male": False, "Performance": None}
   # ensure_ascii=False 处理中文
   json_string = json.dumps(data, ensure_ascii=False)
   # json格式不支持元组，会将其转化为列表；不支持True/False，bool值首字母会转化为小写；不支持None，会转化为null
   print(json_string) # 输出: {"name": "John", "age": 30, "hobies": ["唱", "跳", "rap", "打篮球"], "is_male": false, "Performance": null}
   ```

2. 反序列化：将JSON字符串转换为Python对象：`json.loads()`

   ```python
   import json

   # json格式内部的字符串必须使用""，不能使用''，''会报错
   json_string = '{"name": "John", "age": 30, "hobies": ["唱", "跳", "rap", "打篮球"], "is_male": false, "Performance": null}'
   data = json.loads(json_string)
   print(data["name"])  # 输出: John
   print(data["age"])   # 输出: 30
   print(data["hobies"])   # 输出: ['唱', '跳', 'rap', '打篮球']
   print(data["is_male"])   # 输出: False
   print(data["Performance"])   # 输出: None
   ```

总结：JSON是一种通用的数据交换格式，它通过简洁的文本表示，提供了一种方便、易于解析的方式来表示结构化数据。

#### 应用1：获取豆瓣电影

```python
import requests
import json


def movies_info():
    # url = 'https://frodo.douban.com/api/v2/book/rank_list'
    url = 'https://api.wmdb.tv/api/v1/top?type=Imdb&skip=0&limit=20&lang=Cn'
    headers = {
        'User-Agent': 'MicroMessenger/',
        'Referer': 'https://servicewechat.com/wx2f9b06c1de1ccfca/91/page-frame.html'
    }
    params = {
        'apiKey': '0ac44ae016490db2204ce0a042db2916'
    }

    response = requests.get(url, headers=headers, params=params)
    # data = response.json() # 转化为python数据类型
    # print(response.text) # json格式
    data = json.loads(response.text)  # 转化为python数据类型

    # print(data)
    # print(type(response.text))  # str
    # print(type(data))  # dict
    for i in data:
        yield i
        if type(i) == "dict":
            print(i)
        elif type(i) == "list":
            i = dict(i[0])
            print(i)


printer = movies_info()
# print(next(printer))

for i in printer:
    i = dict(i['data'][0])
    # print(type(i))
    name = i['name']
    movie = i['movie']
    # print(name, movie)
    # 写入文件
    with open("movies.txt", mode="a", encoding="utf-8") as f:
        f.write("{}|{}\n".format(name, movie))
```

#### 应用2：编写一个网站api

```python
from flask import Flask
import json

app = Flask(__name__)


@app.route("/home")
def home():
    return "欢迎使用"


@app.route("/api")
def api():
    info = {"code": 1000, "data": [11, 22, 33]}
    data_string = json.dumps(info)
    return data_string


if __name__ == "__main__":
    app.run()
```

### time 和 datetime

#### time

在Python中，time模块是用于处理时间相关操作的内置模块。它提供了多个函数和方法，可以获取当前时间、进行时间格式化、进行时间计算等操作。

要使用time模块，首先需要导入它：

```python
import time
```

下面是time模块中常用的几个函数和方法：

1. `time()`: 返回当前时间的时间戳（自1970年1月1日以来的秒数）。

   ```python
   timestamp = time.time()
   ```

2. `ctime([seconds])`: 将时间戳转换为可读性好的字符串表示。若不传入参数，默认使用当前时间戳。

   ```python
   current_time = time.ctime()
   ```

3. `sleep(seconds)`: 让程序休眠指定的秒数。

   ```python
   print("start")
   time.sleep(3)  # 程序休眠3秒
   print("end")
   ```

4. `gmtime([seconds])`: 将时间戳转换为UTC时间的struct_time对象。若不传入参数，默认使用当前时间戳。

   ```python
   utc_time = time.gmtime()
   ```

5. `localtime([seconds])`: 将时间戳转换为本地时间的struct_time对象。若不传入参数，默认使用当前时间戳。

   ```python
   local_time = time.localtime()
   ```

6. `strftime(format[, t])`: 格式化时间，将struct_time对象按照指定格式输出。`format`是一个格式化字符串，可以使用特定的占位符表示年、月、日等时间元素。

   ```python
   current_time = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime())
   ```

7. `strptime(string, format)`: 将字符串解析为时间，返回一个struct_time对象。`string`是需要解析的字符串，`format`是一个格式化字符串，用于指定解析的规则。

   ```python
   time_str = "2023-09-13 15:11:17"
   parsed_time = time.strptime(time_str, "%Y-%m-%d %H:%M:%S")
   ```

除了上述函数和方法，time模块还提供了其他一些用于处理时间的函数和常量，如`asctime()`、`mktime()`、`timezone`等。可以根据具体需求选择合适的函数进行使用。

需要注意的是，在处理时间时，可以使用time模块来获取当前时间、进行时间格式化等操作。然而，如果需要进行更复杂的时间计算或处理，建议使用datetime模块，它提供了更多功能丰富的时间处理方法。

```python
import time

# 1. 时间戳（自1970年1月1日至现在所经历的秒数）
data = time.time()
print(data)
print(type(data))  # float

# 2. 主动停2秒（也叫做沉睡2秒）
i = 0
while i < 5:
    i += 1
    print(i)
    time.sleep(1)
```

#### datetime

在Python中，datetime模块是用于处理日期和时间相关操作的内置模块。它提供了多个类和方法，可以创建日期时间对象、进行日期时间计算、进行日期时间格式化等操作。

要使用datetime模块，首先需要导入它：

```python
import datetime
```

下面是datetime模块中常用的几个类和方法：

1. `date(year, month, day)`: 创建一个表示日期的date对象，其中`year`是年份，`month`是月份（1-12），`day`是日期（1-31）。

   ```python
   my_birthday = datetime.date(2000, 1, 1)
   ```

2. `time(hour=0, minute=0, second=0, microsecond=0, tzinfo=None, *, fold=0)`: 创建一个表示时间的time对象，其中`hour`是小时数（0-23），`minute`是分钟数（0-59），`second`是秒数（0-59），`microsecond`是微秒数（0-999999），`tzinfo`是时区信息（默认为None）。

   ```python
   current_time = datetime.time(15, 24, 30)
   ```

3. `datetime(year, month, day, hour=0, minute=0, second=0, microsecond=0, tzinfo=None, *, fold=0)`: 创建一个表示日期时间的datetime对象，其中`year`、`month`、`day`、`hour`、`minute`、`second`、`microsecond`、`tzinfo`同上。

   ```python
   current_datetime = datetime.datetime(2023, 9, 13, 15, 24, 30)
   ```

4. `today()`: 返回当前本地日期。

   ```python
   today = datetime.datetime.today().date()
   ```

5. `now(tz=None)`: 返回当前本地日期时间，参数`tz`指定时区信息（默认为None）。

   ```python
   current_time = datetime.datetime.now().time()
   current_datetime = datetime.datetime.now()
   ```

6. `utcnow()`: 获取当前UTC时间。

   ```python
   utc_time = datetime.datetime.utcnow()
   ```

7. `strftime(format)`: 格式化日期时间，将datetime对象按照指定格式输出。`format`是一个格式化字符串，可以使用特定的占位符表示年、月、日、时、分、秒等时间元素。

   ```python
   current_datetime_str = current_datetime.strftime("%Y-%m-%d %H:%M:%S")
   ```

8. `strptime(date_string, format)`: 将字符串解析为日期时间对象，返回一个datetime对象。`date_string`是需要解析的字符串，`format`是一个格式化字符串，用于指定解析的规则。

   ```python
   date_str = "2023-09-13 15:24:30"
   parsed_datetime = datetime.datetime.strptime(date_str, "%Y-%m-%d %H:%M:%S")
   ```

除了上述类和方法，datetime模块还提供了其他一些用于处理日期和时间的类和方法，如`timedelta`类、`dateutil`模块等。可以根据具体需求选择合适的类或方法进行使用。

需要注意的是，在处理日期和时间时，datetime模块提供了丰富的方法和功能，可以方便地进行日期时间计算、日期时间格式化等操作。同时，datetime模块还提供了多种时区信息表示方式，支持不同时区之间的转换和比较。

```python
from datetime import datetime

# 1. 获取系统时间
data = datetime.now()
print(data)
print(type(data))  # <class 'datetime.datetime'>

# 2. 字符串格式的时间
date_string = data.strftime("%Y-%m-%d %H:%M:%S")
print(date_string)
print(type(date_string))  # <class 'str'>
```

#### 应用1：用户注册+写入文件+注册时间

```python
from datetime import datetime

user = input("用户名：")
pwd = input("密码：")
ctime_string = datetime.now().strftime("%Y-%m-%d")

line = "{}|{}|{}\n".format(user, pwd, ctime_string)
with open("user_info.txt", mode="a", encoding="utf-8") as f:
    f.write(line)
```

#### 应用2：日志按日期写入不同文件

```python
from datetime import datetime

user = input("用户名：")
pwd = input("密码：")
# 为方便演示，精确到分钟
ctime_string = datetime.now().strftime("%Y-%m-%d_%H-%M")
file_name = "{}.log".format(ctime_string)

line = "{}|{}\n".format(user, pwd)
with open(file_name, mode="a", encoding="utf-8") as f:
    f.write(line)
```

#### 时间三种形式之间的转换

```python
import time
from datetime import datetime

# 1. 字符串 转化为 datetime类型
text = "2023-8-12"
data1 = datetime.strptime(text, '%Y-%m-%d')
print(data1)

# 2. datetime类型 转换为 字符串
data2 = datetime.now().strftime("%Y-%m-%m")
print(data2)

# 3. datetime类型 转换为 时间戳
data3 = datetime.now()
data3 = data3.timestamp()
print(data3)

# 4. 时间戳 转换为 datetime类型
data4 = time.time()
data4 = datetime.fromtimestamp(data4)
print(data4)
```

#### 考勤计算

```python
from datetime import datetime

start_string = "2023-08-12 08:47"
start_time = datetime.strptime(start_string, "%Y-%m-%d %H:%M")

end_string = "2023-08-12 18:33"
end_time = datetime.strptime(end_string, "%Y-%m-%d %H:%M")

work_time = end_time - start_time
# print(work_time.seconds)

if work_time.seconds < 28800:
    print("考勤异常")
else:
    print("考勤正常")
```

### os

#### os使用

在Python中，os模块是用于与操作系统进行交互的内置模块。它提供了许多方法和函数，可以用来处理文件和目录、执行系统命令、获取环境变量等。

要使用os模块，首先需要导入它：

```python
import os
```

下面是os模块中常用的几个函数和方法：

1. `os.getcwd()`: 获取当前工作目录的路径。

   ```python
   current_dir = os.getcwd()
   ```

2. `os.chdir(path)`: 修改当前工作目录为指定路径。

   ```python
   os.chdir("/path/to/directory")
   ```

3. `os.listdir(path='.')`: 返回指定目录下所有文件和目录的列表，默认为当前目录。

   ```python
   files = os.listdir("/path/to/directory")
   ```

4. `os.mkdir(path[, mode])`: 创建一个新目录。

   ```python
   os.mkdir("/path/to/new_directory")
   ```

5. `os.makedirs(path[, mode])`: 递归创建多层目录。

   ```python
   os.makedirs("/path/to/new_directory/subdirectory")
   ```

6. `os.remove(path)`: 删除指定文件。

   ```python
   os.remove("/path/to/file")
   ```

7. `os.rmdir(path)`: 删除指定空目录。

   ```python
   os.rmdir("/path/to/directory")
   ```

8. `os.removedirs(path)`: 递归删除指定目录及其子目录。

   ```python
   os.removedirs("/path/to/directory")
   ```

9. `os.rename(src, dst)`: 对文件或目录进行重命名。

   ```python
   os.rename("/path/to/old_file", "/path/to/new_file")
   ```

10. `os.path.join(path1[, path2[, ...]])`: 将多个路径组合成一个路径。

    ```python
    joined_path = os.path.join("/path/to", "file.txt")
    ```

11. `os.path.exists(path)`: 判断指定路径是否存在。

    ```python
    if os.path.exists("/path/to/file"):
        print("File exists")
    ```

12. `os.system(command)`: 执行系统命令。

    ```python
    os.system("ls -l")
    ```

除了上述函数和方法，os模块还提供了其他一些用于处理文件和目录的函数和常量，如`os.path.isfile()`、`os.path.isdir()`、`os.path.abspath()`等。可以根据具体需求选择合适的函数进行使用。

需要注意的是，在使用os模块时，某些函数对于不同的操作系统可能会有所差异，因此在编写跨平台的代码时需要注意兼容性。为了处理文件路径跨平台的差异，建议使用`os.path`模块中的函数来进行路径操作。

```python
import shutil
import os
import time

# 1. 路径的拼接
path = os.path.join("db", "root", "a.txt")
print(path)  # windows：db\root\a.txt

# 2. 获取上级目录
folder_path = os.path.dirname(path)
print(folder_path)   # windows：db\root

# 3. 在项目中读取文件时，使用绝对路径
# 获取当前文件的绝对路径的上级目录
base_dir = os.path.dirname(os.path.abspath(__file__))
file_path = os.path.join(base_dir, "a.txt")
print(file_path)

# 4. 判断路径是否存在
path = os.path.exists(path)
print(path)

# 5. 创建文件夹（默认是相对路径，如果存在会报错）
os.makedirs("pathto/js")
time.sleep(2)

# 6. 判断是否是文件夹
answer = os.path.isdir(base_dir)
print(answer)

# 创建文件
with open("pathto/js/jQuery.js", 'w') as f:
    f.write('Hello, world!')
time.sleep(2)

# 7. 删除文件
os.remove("pathto/js/jQuery.js")
time.sleep(2)

# # 8. 删除文件夹
shutil.rmtree("pathto/js")

# 9. 查看该目录下所有文件及文件夹（不包括子目录）
for name in os.listdir("pathto/js/"):
    file_path = os.path.join(base_dir, name)
    print(name)
    print(file_path)

# 10. 查看该目录下所有文件（包括子目录）
for path, folder_list, file_list in os.walk(base_dir):
    # print(i) # ('H:\\1_python开发\\99\\script', ['.vscode', '2023-08', 'static', '__pycache__'], ['a1.html', 'a1.txt', 'a2.txt', 'mainProject.py', 'module_1.py', 'user_info.txt'])
    # break
    for file_name in file_list:
        abs_path = os.path.join(path, file_name)
        print(abs_path)
```

#### 应用1：用户访问日志

```python
import os
from datetime import datetime

base_dir = os.path.dirname(os.path.abspath(__file__))

# 用户名和密码
user = input("用户名：")
pwd = input("密码：")
line = "{}|{}\n".format(user, pwd)

# 判断文件夹是否存在，不存在则创建(在当前路径下按月创建文件夹)
date_string = datetime.now().strftime("%Y-%m")
folder_path = os.path.join(base_dir, date_string)
if not os.path.exists(folder_path):
    os.makedirs(folder_path)

# 拼接文件路径（在文件夹内按日期创建文件）
today_string = datetime.now().strftime("%Y-%m-%d")
file_path = os.path.join(folder_path, "{}.log".format(today_string))
with open(file_path, mode="a", encoding="utf-8") as f:
    f.write(line)
```

#### 应用2：景区订票系统

- 启动项目时，检测当前项目目录下是否有 db 目录，如果没有就创建。
- 提示输入用户名，进入系统，检测 db/用户名.txt 文件
  - 存在，老用户；
  - 不存在，新用户。
- 订票
  - 输入景区：名字、数量
  - 名字、数量、预定时间 写入到 db/用户名.txt 中
- 查看历史订单
  - 读取 db/用户名.txt 的内容逐行输出。

```python
import os
from datetime import datetime

BASE_DIR = os.path.dirname(os.path.abspath(__file__))
DB_PATH = os.path.join(BASE_DIR, 'db')


def booking(file_path):
    orders = input("请输入您想预定的景区：")
    if orders.upper() == "Q":
        return
    num = input("请输入您要预定几张票：")
    ctime = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    line = "{}|{}|{}\n".format(orders, num, ctime)
    with open(file_path, mode="a", encoding="utf-8") as f:
        f.write(line)
        f.flush()
    print("预定成功！")


def history(file_path):
    if not os.path.exists(file_path):
        print("暂无历史订单")
        return
    with open(file_path, mode="r", encoding="utf-8") as f:
        for item in f:
            item = item.strip()
            if not item:
                continue
            print(item)


def run():
    # 1. 文件夹的初始化
    if not os.path.exists(DB_PATH):
        os.makedirs(DB_PATH)

    # 2. 输入姓名，新用户/老用户
    user_name = input("用户名：")
    file_path = os.path.join(DB_PATH, "{}.txt".format(user_name))
    if os.path.exists(file_path):
        print("老用户")
    else:
        print("新用户")

    # 3. 用户选择：1. 预定 2. 查看历史订单
    func_dict = {"1": booking, "2": history}
    while True:
        action = input("请选择您需要的服务：\n1. 预定\n2. 查看历史订单\n")
        func = func_dict.get(action)
        if action.upper() == "Q":
            break
        elif not func:
            print("本站不提供此服务，请重新选择")
            continue
        func(file_path)


if __name__ == "__main__":
    run()
```

### sys

在Python中，sys模块是用于访问Python解释器及其环境的内置模块。它提供了许多方法和属性，可以用于获取Python解释器的信息、修改Python解释器的行为、从命令行获取参数等。

要使用sys模块，首先需要导入它：

```python
import sys
```

下面是sys模块中常用的几个函数和属性：

1. `sys.argv`: 包含命令行参数的列表。

   ```python
   # 假设脚本名称为script.py，执行命令python script.py arg1 arg2
   print(sys.argv)  # ['script.py', 'arg1', 'arg2']
   ```

2. `sys.stdin`: 标准输入流对象。

   ```python
   input_str = sys.stdin.readline()  # 从标准输入读取一行数据
   ```

3. `sys.stdout`: 标准输出流对象。

   ```python
   sys.stdout.write("Hello, world!\n")  # 输出字符串到标准输出
   ```

4. `sys.stderr`: 标准错误输出流对象。

   ```python
   sys.stderr.write("Error occurred!\n")  # 输出错误信息到标准错误输出
   ```

5. `sys.exit([arg])`: 结束当前进程并返回指定的状态码，默认为0。

   ```python
   sys.exit(1)  # 返回状态码1并结束进程
   ```

6. `sys.version`: 当前Python解释器的版本信息。

   ```python
   print(sys.version)  # 输出Python版本信息
   ```

7. `sys.path`: 包含模块搜索路径的列表。

   ```python
   print(sys.path)  # 输出模块搜索路径
   ```

除了上述函数和属性，sys模块还提供了其他一些用于控制Python解释器行为的方法和常量，如`sys.settrace()`、`sys.maxsize`、`sys.platform`等。可以根据具体需求选择合适的函数进行使用。

需要注意的是，在使用sys模块时，部分函数会直接影响Python解释器的行为，因此需要谨慎使用。同时，由于sys模块提供了修改Python解释器行为的方法，因此可能会导致代码在不同平台或不同版本的Python解释器中产生不同的结果。

```python
import sys

# 1. 导入模块时，到哪里找
print(sys.path)  # 返回一个列表

# 2. 获取运行脚本时传入的参数
print(sys.argv)  # 返回一个列表

name = sys.argv[1]
age = sys.argv[2]
token = sys.argv[3]

data_string = "{}-{}".format(name, token)
# python .\mainProject.py 张三 19  sdfowieng
print(data_string)  # 张三-sdfowieng
```

### shutil

在Python中，shutil模块是一个用于高级文件操作的标准库模块。它提供了许多函数来执行文件和目录的复制、移动、重命名以及删除等操作。使用shutil模块可以简化对文件和目录的操作。

要使用shutil模块，首先需要导入它：

```python
import shutil
```

下面是shutil模块中常用的几个函数：

1. `shutil.copy(src, dst)`: 复制文件或目录从源路径src到目标路径dst。

   ```python
   shutil.copy("source.txt", "destination.txt")  # 复制文件
   shutil.copytree("source_dir", "destination_dir")  # 递归复制目录及其内容
   ```

2. `shutil.move(src, dst)`: 移动文件或目录从源路径src到目标路径dst，如果目标路径已经存在，则会替换目标路径。

   ```python
   shutil.move("source.txt", "destination.txt")  # 移动文件
   shutil.move("source_dir", "destination_dir")  # 移动目录
   ```

3. `shutil.rmtree(path)`: 递归删除指定目录及其内容。

   ```python
   shutil.rmtree("directory_to_delete")  # 删除目录及其内容
   ```

4. `shutil.rmtree(path[, ignore_errors[, onerror]])`: 递归删除指定目录及其内容，并提供更多删除选项。

   ```python
   shutil.rmtree("directory_to_delete", ignore_errors=True)  # 删除目录及其内容，忽略错误
   shutil.rmtree("directory_to_delete", onerror=handle_error)  # 删除目录及其内容，自定义错误处理函数
   ```

5. `shutil.rename(src, dst)`: 对文件或目录进行重命名。

   ```python
   shutil.rename("old_name.txt", "new_name.txt")  # 重命名文件
   shutil.rename("old_directory", "new_directory")  # 重命名目录
   ```

6. `shutil.which(cmd)`: 在系统的PATH中搜索指定的可执行文件，并返回第一个找到的路径。

   ```python
   executable_path = shutil.which("python")  # 查找可执行文件的路径
   ```

除了上述函数，shutil模块还提供了其他一些用于文件和目录操作的函数，如`shutil.disk_usage()`、`shutil.make_archive()`等。可以根据具体需求选择合适的函数进行使用。

需要注意的是，在使用shutil模块时，请务必小心操作，特别是对于删除文件和目录的操作，要格外谨慎以免误删重要数据。在进行文件操作时，建议先进行异常处理，以便捕获可能出现的错误。

```python
import shutil

# 1. 删除文件夹
shutil.rmtree("文件夹路径")

# 2. 重命名文件或文件夹
shutil.move("old_name", "new_name")

# 3. 拷贝文件夹
shutil.copytree("old_path/folder", "new_path/folder")

# 4. 拷贝文件
shutil.copy("old_path/filename", "new_path/filename")

# 5. 压缩：把当前路径下的db目录打包为a1.zip
shutil.make_archive(base_name="a1", format="zip", root_dir="db")

# 6. 解压缩：把a1.zip解压缩
shutil.unpack_archive("a1.zip", extract_dir="db", format="zip")
```

### configparser:对某特定格式的文件（配置文件）进行操作

#### configparser功能演示

在Python中，configparser模块提供了一种方便的方式来从配置文件中读取配置信息。配置文件是一个普通的文本文件，使用该模块可以轻松地进行读取、修改和写入操作。configparser模块适用于各种应用程序，如Web应用程序、桌面应用程序等。

要使用configparser模块，首先需要导入它：

```python
import configparser
```

下面是configparser模块中常用的几个类和方法：

1. `configparser.ConfigParser()`: 创建配置文件解析器对象。

2. `configparser.read(filename)`: 从指定的文件名filename中读取配置信息。

   ```python
   config = configparser.ConfigParser()
   config.read('config.ini')
   ```

3. `configparser.sections()`: 返回配置文件中所有节（section）的列表。

   ```python
   sections = config.sections()
   ```

4. `configparser.options(section)`: 返回指定节（section）下的所有选项（option）的列表。

   ```python
   options = config.options('Database')
   ```

5. `configparser.get(section, option)`: 返回指定节（section）下指定选项（option）的值。

   ```python
   username = config.get('Database', 'username')
   ```

6. `configparser.set(section, option, value)`: 设置指定节（section）下指定选项（option）的值为value。

   ```python
   config.set('Database', 'username', 'admin')
   ```

7. `configparser.write(fileobject)`: 将配置信息写入到文件对象fileobject中。

   ```python
   with open('config.ini', 'w') as f:
       config.write(f)
   ```

除了上述方法，configparser模块还提供了其他一些用于配置文件操作的方法和属性，如`configparser.has_section()`、`configparser.remove_option()`、`configparser.defaults`等。可以根据具体需求选择合适的方法进行使用。

需要注意的是，在使用configparser模块时，配置文件应该是规范的INI格式，即以[section]开头的节和key=value形式的选项。如果配置文件格式不正确，则会导致读取失败。同时，由于配置文件包含了应用程序的重要信息，因此要确保配置文件的安全性，例如将敏感信息加密存储或采用其他方式进行保护。

```python
import configparser
import os

BASE_DIR = os.path.dirname(os.path.abspath(__file__))
FILE_PATH = os.path.join(BASE_DIR, "my.ini")

config = configparser.ConfigParser()
config.read(FILE_PATH, encoding="utf-8")

# 1. 获取所有节点
v1 = config.sections()
print(v1)  # ['server', 'client']

# 2. 获取节点下的键值
v2 = config.items("server")
for k, v in v2:
    print(k, v)

# # 3. 节点下的某个键值对的值
v3 = config.get("server", "v3")
print(v3)

# # 4. 是否存在某个节点
v4 = config.has_section("server")
print(v4)  # True

# 5. 添加节点
config.add_section("group")
config.set("group", "name", "k8s_client_1")
config.set("group", "address", "127.0.0.2")
# 如果不写入文件，添加的内容只会添加到内存中，不会修改配置文件
with open(FILE_PATH, mode="w", encoding="utf-8") as f:
    config.write(f)

# 6. 删除节点
config.remove_section("group")
with open(FILE_PATH, mode="w", encoding="utf-8") as f:
    config.write(f)

# 7. 删除键值对
config.remove_option("server", "v2")
with open(FILE_PATH, mode="w", encoding="utf-8") as f:
    config.write(f)

# 8. 修改
config.set("server", "v1", "哈哈哈")
with open(FILE_PATH, mode="w", encoding="utf-8") as f:
    config.write(f)
```

#### 应用1：MySQL配置

```python
import configparser
import os
import json


def preprocess_config_file(file_path):
    """处理配置文件的注释行和空行"""
    filtered_lines = []
    with open(file_path, 'r', encoding='utf-8') as file:
        for line in file:
            stripped_line = line.strip()
            if stripped_line and not stripped_line.startswith('#') and not stripped_line.startswith(';'):
                filtered_lines.append(stripped_line)

    return '\n'.join(filtered_lines)


BASE_DIR = os.path.dirname(os.path.abspath(__file__))
FILE_PATH = os.path.join(BASE_DIR, "my.cnf")

config_content = preprocess_config_file(FILE_PATH)
config = configparser.ConfigParser()
config.read_string(config_content)

# 将配置添加到字典
result = {}

sec_list = config.sections()
for sec in sec_list:
    result[sec] = {}
    for k, v in config.items(sec):
        result[sec][k] = v

# 将字典格式化输出
result = json.dumps(result, indent=2)
print(result)
```

[my.cnf](99/script/my.cnf)

#### 应用2: 爬取知乎评论(接口不可用)

```python
import configparser
import os
import json
import requests

BASE_DIR = os.path.dirname(os.path.abspath(__file__))
FILE_PATH = os.path.join(BASE_DIR, "setting.int")


def preprocess_config_file(file_path):
    """处理配置文件的注释行和空行"""
    filtered_lines = []
    with open(file_path, 'r', encoding='utf-8') as file:
        for line in file:
            stripped_line = line.strip()
            if stripped_line and not stripped_line.startswith('#') and not stripped_line.startswith(';'):
                filtered_lines.append(stripped_line)

    return '\n'.join(filtered_lines)


def init_settings():
    config_content = preprocess_config_file(FILE_PATH)
    config = configparser.ConfigParser()
    config.read_string(config_content)
    # 将配置添加到字典
    result = {}
    sec_list = config.sections()
    for sec in sec_list:
        result[sec] = {}
        for k, v in config.items(sec):
            result[sec][k] = v
    return result


def run():
    settings = init_settings()
    print(settings)

    # 1. 下载返回的数据
    url = settings["zhihu"]["url"]
    res = requests.get(
        url=url,
        headers={
            "user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.0.0 Safari/537.36 Edg/113.0.1774.50"
        }
    )
    res.encoding = "utf-8"

    data_dict = json.loads(res.text)
    file_name = settings["zhihu"]["file"]
    abs_file_path = os.path.join[BASE_DIR, file_name]
    with open(abs_file_path, mode="a", encoding="utf-8") as f:
        for item in data_dict["data"]:
            name = item["author"]["name"]
            content = item["content"]
            f.write(content + "\n")


if __name__ == "__main__":
    run()
```

```ini
"""settings.ini"""
[zhihu]
url=https://www.zhihu.com/api/v4/comment_v5/answers/2578184140/root_comment?order_by=score&limit=20&offset=
file=db.txt
```

### xml

#### XML语言

XML（可扩展标记语言）是一种用于描述数据的标记语言。它的设计目标是传输数据而不是显示数据，因此它具有良好的跨平台性和可扩展性。
XML使用标签来定义数据元素，每个元素可以包含子元素、属性和文本内容。以下是一个简单的XML示例：

```xml
<bookstore>
  <book category="科幻">
    <title>2001太空漫游</title>
    <author>阿瑟·克拉克</author>
    <year>1968</year>
  </book>
  <book category="小说">
    <title>了不起的盖茨比</title>
    <author>斯科特·菲茨杰拉德</author>
    <year>1925</year>
  </book>
</bookstore>
```

在这个例子中，`<bookstore>` 是根元素，它包含两个 `<book>` 元素作为子元素。每个 `<book>` 元素都有一个 `category` 属性，并包含 `<title>`、`<author>` 和 `<year>` 元素作为子元素。

XML具有以下特点：

1. **可读性**: XML使用标签和结构化的元素来表示数据，使其易于阅读和理解。
2. **可扩展性**: XML允许用户自定义标签名和数据结构，使其非常灵活和可扩展。
3. **平台无关性**: XML是与平台和编程语言无关的，可以在不同的系统和应用程序之间进行数据交换。
4. **自我描述性**: XML文档可以包含文档类型定义（DTD）或XML模式定义（XSD），用于定义文档的结构和规则。

XML常用于以下方面：

- 数据交换：XML可以作为一种通用的数据格式，在不同系统之间传输和共享数据。
- 配置文件：许多软件使用XML格式来存储和管理配置信息。
- 网络通信：Web服务和SOAP（简单对象访问协议）等技术使用XML来传递和解析数据。

对于处理XML数据，可以使用不同的编程语言和库，如Python中的ElementTree、lxml、xml.dom等，这些库提供了方便的API来读取、写入和修改XML数据。

#### xml使用

在Python中，xml模块提供了处理XML（可扩展标记语言）文件的功能。XML是一种用于存储和传输数据的标记语言，具有良好的可读性和结构化特性。xml模块可以用于解析和生成XML文档，使我们能够方便地读取和操作XML数据。

要使用xml模块，首先需要导入它：

```python
import xml.etree.ElementTree as ET
```

下面是xml模块中常用的几个类和方法：

1. `ElementTree.parse(file)`: 解析XML文件，并返回一个ElementTree对象。

   ```python
   tree = ET.parse('data.xml')
   ```

2. `ElementTree.fromstring(string)`: 解析XML字符串，并返回一个Element对象。

   ```python
   xml_string = '<root><item>Value</item></root>'
   root = ET.fromstring(xml_string)
   ```

3. `ElementTree.Element(tag, attrib={}, **extra)`: 创建一个具有指定标签名和属性的Element对象。

   ```python
   root = ET.Element('root')
   ```

4. `Element.append(elem)`: 向元素中添加子元素。

   ```python
   child = ET.Element('child')
   root.append(child)
   ```

5. `Element.find(path)`: 查找匹配给定路径的第一个子元素，并返回该元素。

   ```python
   element = root.find('item')
   ```

6. `Element.text`: 获取或设置元素的文本内容。

   ```python
   text = element.text # 获取元素的文本内容
   element.text = 'New Value' # 设置元素的文本内容
   ```

7. `Element.attrib`: 获取或设置元素的属性字典。

   ```python
   attrib = element.attrib # 获取元素的属性字典。
   element.attrib['property'] = 'value' #设置元素的属性字典。
   ```

8. `ElementTree.ElementTree(element=None, file=None)`: 创建一个ElementTree对象，可选地使用Element对象或文件名作为参数。

   ```python
   tree = ET.ElementTree(root) # 创建一个ElementTree对象
   tree.write('output.xml') # 写入文件
   ```

除了上述方法，xml模块还提供了其他一些用于处理XML文件的方法和属性，如`Element.findall()`、`Element.get()`、`Element.remove()`等。可以根据具体需求选择合适的方法进行使用。

需要注意的是，在使用xml模块解析XML文件时，如果XML文件不符合XML规范，则会导致解析失败。因此，在处理XML文件之前，建议先进行XML格式的验证。此外，对于大型XML文件或复杂的XML操作，可以考虑使用lxml库，它提供了更高效和灵活的XML处理能力。

```python
from xml.etree import ElementTree

text = """
<bookstore>
  <book category="科幻">
    <title>2001太空漫游</title>
    <author>阿瑟·克拉克</author>
    <year>1968</year>
    <user id="12345" active="true" />
  </book>
  <book category="小说">
    <title>了不起的盖茨比</title>
    <author>斯科特·菲茨杰拉德</author>
    <year>1925</year>
    <user id="12345" active="true" />
  </book>
</bookstore>
"""

root = ElementTree.XML(text)
node = root.find("book")
node_list = root.findall("book")
print(node)  # <Element 'book' at 0x0000029657AA9490>
print(node_list)  # list
# 获取标签
print(node.tag)  # book
# 获取参数
print(node.attrib)  # {'category': '科幻'}
# 获取内容
print(node.text)
for node in node_list:
    print(node.tag, node.attrib)
    for item in node:
        print(item.tag, item.attrib, item.text)
```

#### 应用1：XML数据转化为字典

```python
from xml.etree import ElementTree

text = """
<book>
  <title>2001太空漫游</title>
  <author>阿瑟·克拉克</author>
  <year>1968</year>
</book>
"""

data_dict = {}
root = ElementTree.XML(text)
for node in root:
    data_dict[node.tag] = node.text
print(data_dict)
```

### re

#### 正则表达式

正则表达式是一种特殊的字符串模式，用于匹配、搜索和操作文本。它使用一系列的符号和特殊字符来定义模式，然后根据这个模式来匹配目标字符串。

1. 正则表达式的基本元字符：
   - 字母和数字：表示字面量匹配。例如：`a`、`b`、`1`、`2`等。
   - 元字符（特殊字符）：具有特殊含义的符号。例如：`*`、`.`、`+`、`?`、`\`等。
2. 正则表达式的基本规则：
   - 字面匹配：正则表达式中的字母和数字直接匹配目标字符串中相应位置的字符。例如：正则表达式 `abc` 可以匹配目标字符串中的 `abc`。
   - 元字符匹配：正则表达式中的元字符具有特殊的匹配规则。例如：`*` 匹配前一个元素的零次或多次重复。
3. 常用的元字符和语法：
   - `.`: 匹配除换行符以外的任意字符。
   - `*`: 匹配前一个元素的零次或多次重复。
   - `+`: 匹配前一个元素的一次或多次重复。
   - `?`: 匹配前一个元素的零次或一次重复。
   - `[]`: 匹配指定字符集合中的任意一个字符。
   - `^`: 匹配输入字符串的开始位置。
   - `$`: 匹配输入字符串的结束位置。
   - `\`: 转义字符，用于转义元字符以及表示特殊的匹配模式。
   - `\d`: 匹配任意一个数字字符。
   - `\w`: 匹配任意一个字母或数字字符。
   - `\s`: 匹配任意一个空白字符。
   - `|`: 匹配多个模式中的任意一个。
4. 正则表达式的应用场景：
   - **文本匹配和搜索**：可以根据特定模式查找和提取目标字符串中的内容。
   - **数据验证**：可以验证用户输入的数据是否符合指定的格式要求。
   - **替换与修改**：可以使用正则表达式查找并替换目标字符串中的指定内容。
   - **数据提取和分析**：可以从复杂的文本数据中提取出特定的信息。
需要注意的是，正则表达式非常强大，但也较为复杂。在使用正则表达式时，建议先了解其基本语法，并对测试数据进行验证和调试，以确保达到预期的匹配效果。

#### re相关函数和方法

在Python中，re（正则表达式）模块是用于处理正则表达式的内置模块。正则表达式是一种强大的文本匹配和处理工具，可以用于在字符串中文本匹配、搜索、替换、分割等操作。

要使用re模块，首先需要导入它：

```python
import re
```

下面是re模块中常用的几个函数和方法：

1. `re.findall(pattern, string, flags=0)`：在字符串中搜索匹配模式的所有位置，将所有匹配的结果以列表形式返回。
   - 检索固定文本

      ```python
      import re

      text = "你好zhangsan,siowensdozhangsan,色哦i但哦zhangsan"
      data_list = re.findall(r"zhangsan", text)
      print(data_list) # ['zhangsan', 'zhangsan', 'zhangsan']
      ```

   - 检索含特定字符的文本

      ```python
      import re

      text = "你好zhangsaa,siowensdozhangsab,色哦i但哦zhangsac"
      data_list = re.findall(r"zhangsa[abc]", text)
      print(data_list) # ['zhangsaa', 'zhangsab', 'zhangsac']
      # 简写
      data_list = re.findall(r"a[a-z]", text)
      print(data_list) # ['an', 'aa', 'an', 'ab', 'an', 'ac']
      # 多个
      data_list = re.findall(r"a[a-z]{2}", text)
      print(data_list) # ['ang', 'ang', 'ang']
      # 动态2-5个
      data_list = re.findall(r"a[a-z]{2,5}", text)
      print(data_list) # ['angsaa', 'angsab', 'angsac']
      ```

   - 匹配邮箱和手机号

      ```python
      import re

      text = """
      这是一段示例文本，其中包含了一些手机号和邮箱地址。
      我的电话号码是：13812345678，电子邮箱是：test@example.com。
      另一个手机号是：13998765432，邮箱地址是：another@test.com。
      """
      # 提取手机号
      phone_numbers = re.findall(r"\b1[3456789]\d{9}\b", text)
      print("提取的手机号：", phone_numbers)
      # 提取邮箱地址
      email_addresses = re.findall(
         r"\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}\b", text)
      print("提取的邮箱地址：", email_addresses)
      ```

2. `re.match(pattern, string, flags=0)`：从字符串的开头开始匹配，如果匹配成功，则返回一个匹配对象；否则返回 None。

   ```python
   import re

   email = input("邮箱：")
   # 利用正则对用户提交的数据进行校验
   is_valid = re.match(r"^\w+@\w+\.\w+$", email)
   if is_valid:
      print("合法邮箱")
   else:
      print("非法邮箱")
   ```

3. `re.search(pattern, string, flags=0)`：在字符串中搜索匹配模式的第一个位置，如果匹配成功，则返回一个匹配对象；否则返回 None。

   ```python
   import re

   text = "My phone number is 13812345678."
   pattern = r"\b1[3456789]\d{9}\b"  # 匹配手机号的正则表达式模式
   match = re.search(pattern, text)
   if match:
      phone_number = match.group()
      print("提取的手机号：", phone_number)
   else:
      print("未找到手机号。")
      # 输出：提取的手机号： 13812345678
   ```

   在上述示例中，使用了 `re.search()` 函数和正则表达式模式 `\b1[3456789]\d{9}\b` 来搜索并匹配手机号。其中，`\b` 表示单词边界，`1[3456789]` 表示第一个数字为1，第二个数字为3、4、5、6、7、8、9 中的任意一个，`\d{9}` 表示后面跟着9个数字字符。

4. `re.sub(pattern, repl, string, count=0, flags=0)`：用指定替换字符串 repl 替换字符串中所有匹配的模式，可选参数 count 控制替换次数。

   ```python
   import re

   text = "Hello, [name]! How are you, [name]?"
   pattern = r"\[name\]"  # 匹配模式
   replacement = "John"  # 替换字符串
   new_text = re.sub(pattern, replacement, text)
   print("替换后的字符串：", new_text)
   # 输出：替换后的字符串： Hello, John! How are you, John?
   ```

5. `re.split(pattern, string, maxsplit=0, flags=0)`：将字符串按照匹配模式进行分割，返回分割后的列表。

   ```python
   import re

   text = "apple,banana,grape,orange"
   pattern = r","  # 匹配模式-逗号
   result = re.split(pattern, text)
   print("分割后的列表：", result)
   # 输出：分割后的列表： ['apple', 'banana', 'grape', 'orange']
   ```

6. `re.compile(pattern, flags=0)`: 编译正则表达式`pattern`，返回一个正则表达式对象。可以提高正则表达式的重复使用性能。

   ```python
   pattern = re.compile(r'\bword\b', flags=re.IGNORECASE)
   match = pattern.search('This is the Word')
   ```

除了上述方法，re模块还提供了其他一些函数和方法用于处理正则表达式，如`re.subn()`、`re.finditer()`、`re.escape()`等。可以根据具体需求选择合适的方法进行使用。
需要注意的是，正则表达式具有强大的功能和灵活性，但也较为复杂。在使用正则表达式时，建议先编写和测试表达式，并理解其语法和规则，以确保正确匹配和处理目标文本。

## 第三方模块

### 配置第三方镜像源

1. 查看当前pip镜像源：`pip config list`，`pip config get global.index-url`
2. 配置清华镜像源：`pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple`
3. 永久配置：
   1. 打开电脑的资源管理器，输入`%APPDATA%`跳转到对应路径，找到其下的`pip\pip.ini`或`pip\pip.conf`
   2. 编辑该配置文件

      ```conf
      # 阿里云镜像地址
      [global]
      index-url = https://mirrors.aliyun.com/pypi/simple/
      trusted-host = mirrors.aliyun.com
      ```

      ```conf
      # 清华镜像地址
      [global]
      index-url = https://pypi.tuna.tsinghua.edu.cn/simple
      trusted-host = pypi.tuna.tsinghua.edu.cn
      ```

### 虚拟环境

Python的虚拟环境是一种用于隔离和管理项目所需依赖包的机制。它允许在同一台计算机上同时管理多个独立的Python环境，每个环境可以拥有不同的Python版本和安装的第三方库，互相之间不会产生冲突。

1. 虚拟环境的优点：
   1. 隔离依赖：虚拟环境可以确保每个项目都有自己的独立环境，不受其他项目所安装的依赖包的影响。这样可以避免不同项目之间的依赖冲突。
   2. 版本管理：通过使用不同的虚拟环境，可以轻松地在项目之间切换Python版本。这对于需要同时支持多个Python版本或测试新的Python版本非常有用。
   3. 依赖隔离：每个虚拟环境都可以有自己特定的第三方库版本，这样可以确保不同项目使用不同的库版本，避免版本不兼容的问题。
2. 在Python中，有几种流行的虚拟环境管理工具，如`virtualenv`、`venv`和`conda`等。下面是一个简单的使用示例（使用`venv`内置模块）来创建和激活虚拟环境：
   1. 创建虚拟环境：
      打开终端（命令行窗口），导航到项目的目录，并执行以下命令来创建一个新的虚拟环境：`python -m venv .venv`
   2. 激活虚拟环境：
      在Windows系统上，执行以下命令：`.\.venv\Scripts\activate`
      在Linux或Mac系统上，执行以下命令：`source .venv/bin/activate`
   3. 安装依赖：
      在虚拟环境激活后，可以使用`pip`安装项目所需的依赖包，例如：
      `pip install requests`
   4. 运行项目：
      在虚拟环境中运行项目，它将使用该环境所安装的Python和依赖包。
      `python app.py`
   5. 退出虚拟环境：
      完成项目工作后，可以使用以下命令退出虚拟环境：`deactivate`
3. 划分目录，一般推荐：
   1. 项目：`D:\code\program1`
   2. 环境：`D:\code\program1\.venv`
4. 常见问题：
   1. 代码上传：
      - 【不行】仅代码
      - 【不行】代码 + 虚拟环境
      - 【可行】代码 + requirements.txt，`pip freeze > requirements.txt`
      - 要排除虚拟环境，否则文件会很大
   2. 获取代码后运行：
      - 创建虚拟环境并与当前项目绑定
      - 安装依赖包（在虚拟环境命令行）：`pip install -r requirements.txt`

### requests & bs4.BeautifulSoup

#### requests

在Python中，requests模块是一个流行的第三方库，用于发送HTTP请求并处理响应。它提供了一组简洁而强大的接口，使得在Python中进行网络通信变得更加容易。

要使用requests模块，首先需要安装它。可以使用pip命令进行安装：`pip install requests`

下面是requests模块中常用的几个函数和方法：

1. `requests.get(url, params=None, **kwargs)`: 发送一个GET请求，并返回一个包含响应内容的Response对象。

   ```python
   import requests

   response = requests.get('https://api.example.com/data', params={'key': 'value'})
   ```

2. `requests.post(url, data=None, json=None, **kwargs)`: 发送一个POST请求，并返回一个包含响应内容的Response对象。

   ```python
   import requests

   response = requests.post('https://api.example.com/submit', data={'name': 'John', 'age': 30})
   ```

3. `requests.put(url, data=None, **kwargs)`: 发送一个PUT请求，并返回一个包含响应内容的Response对象。

4. `requests.delete(url, **kwargs)`: 发送一个DELETE请求，并返回一个包含响应内容的Response对象。

5. `requests.head(url, **kwargs)`: 发送一个HEAD请求，并返回一个包含响应内容的Response对象。

6. `requests.options(url, **kwargs)`: 发送一个OPTIONS请求，并返回一个包含响应内容的Response对象。

以上这些函数都会返回一个包含响应内容的Response对象，可以使用该对象来获取请求的状态码、响应头、响应内容等信息，并对其进行操作和处理。例如：

```python
import requests

response = requests.get('https://api.example.com/data')
print(response.status_code)  # 输出状态码
print(response.headers)      # 输出响应头
print(response.text)         # 输出响应内容
```

除了上述方法，requests模块还提供了其他一些功能，如处理Cookies、设置请求头、响应内容的序列化等。可以根据具体需求查阅官方文档或其他参考资料来学习更多关于requests模块的用法和技巧。

需要注意的是，在使用requests模块发送请求时，应该遵守相关的网络通信规范和法律法规，确保合法性和安全性。

#### bs4.BeautifulSoup

在Python中，bs4.BeautifulSoup模块是一个用于解析HTML和XML文档的第三方库，其中最常用的功能是从HTML文档中提取数据。它不仅支持标准的HTML和XML格式，还支持一些复杂的文档结构和编码格式。
要使用bs4.BeautifulSoup模块，首先需要安装它。可以使用pip命令进行安装：`pip install beautifulsoup4`

下面是bs4.BeautifulSoup模块中常用的几个函数和方法：

1. `bs4.BeautifulSoup(markup, features=None)`: 用于将HTML或XML文档转换为BeautifulSoup对象。

   ```python
   from bs4 import BeautifulSoup
   import requests

   response = requests.get('https://www.example.com')
   soup = BeautifulSoup(response.text, 'html.parser')
   ```

2. `soup.find(name=None, attrs={}, recursive=True, text=None, **kwargs)`: 用于查找文档中符合条件的第一个标签，并返回一个Tag对象。

   ```python
   tag = soup.find('a', href='/about')
   ```

3. `soup.find_all(name=None, attrs={}, recursive=True, text=None, limit=None, **kwargs)`: 用于查找文档中所有符合条件的标签，并返回一个包含Tag对象的列表。

   ```python
   tags = soup.find_all('a', class_='link')
   ```

4. `tag.contents`: 获取标签内部的所有子节点，返回一个包含子节点的列表。

5. `tag.children`: 获取标签内部的所有直接子节点，返回一个生成器。

6. `tag.parent`: 获取标签的父节点，返回一个Tag对象。

以上这些函数和方法都可以用来在HTML文档中查找和提取内容，可根据具体需求选择相应的方法进行使用。例如：

```python
from bs4 import BeautifulSoup
import requests

response = requests.get('https://www.example.com')
soup = BeautifulSoup(response.text, 'html.parser')

# 查找<a>标签中的链接
links = soup.find_all('a', href=True)
for link in links:
    print(link['href'])
```

除了上述方法，bs4.BeautifulSoup模块还支持一些高级特性，如CSS选择器、文档遍历、抽取属性等。可以通过官方文档或其他参考资料来学习更多关于bs4.BeautifulSoup模块的用法和技巧。

需要注意的是，在使用bs4.BeautifulSoup模块解析HTML或XML文档时，应该理解文档结构和标签语义，并遵守相关的Web标准和法律法规，确保合法性和安全性。

#### requests案例

1. 获取知乎评论

   ```python
   import requests

   res = requests.get(
      url="https://www.zhihu.com/api/v4/comment_v5/articles/510792263/root_comment?order_by=score&limit=20&offset=",
      headers={
         "user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36",
         "referer": "https://zhuanlan.zhihu.com/p/510792263"
      },
      cookies={
         "_zap": "d79e7851-7bfc-4306-88ac-701ca4329a38",
         "_xsrf": "46dad0e8-66e6-4073-8aa1-11b42e0faf6a"
      }
   )
   # 响应体
   res.encoding = "utf-8"
   print(res.text)

   # 响应头
   print(res.headers)
   ```

2. 获取豆瓣电影：处理JSON格式数据

   ```python
   import requests

   count = 0
   # 请求12条数据，每次3条，最后一个参数与url中count的值保持一致
   for i in range(0, 12, 3):
      res = requests.get(
         url="https://m.douban.com/rexxar/api/v2/movie/recommend?refresh=0&start={}&count=3&selected_categories=%7B%7D&uncollect=false&playable=true&tags=".format(
               i),
         headers={
               "user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36",
               "referer": "https://movie.douban.com/explore",
               "Content-Type": "application/json; charset=utf-8"
         },
         cookies={
               "ll": "118281",
               "bid": "YrVDXSQ0WeQ"
         }
      )
      data_dict = res.json()
      for items in data_dict["items"]:
         title = items["title"]
         id = items["id"]
         comment = items["comment"]["comment"]
         count += 1
         print(count, title, id, comment)
   ```

3. 处理 JSONP格式数据
   JSONP（JSON with Padding）是一种解决跨域请求的技术，在某些情况下，服务器会返回一个包裹在函数调用中的 JSON 数据，而不是直接返回纯 JSON 数据。这个函数会由前端进行定义和执行，从而达到跨域的目的。JSONP 数据通常是一个 JavaScript 函数调用，其中的参数是 JSON 数据，形如`callback({"key":"value"})`。因此只需提取出其中的JSON部分，再处理JSON数据即可。
   `data = res.text.strip()[0:-1]`
   需要注意的是，这种方法仅在 JSONP 数据格式符合预期且没有其他附加内容时才适用。如果 JSONP 数据中包含其他非 JSON 部分，或者有多个函数调用的情况，可能需要使用更复杂的方法进行处理。

   ```python
   import json
   import requests

   def parse_jsonp(jsonp):
      # 提取JSONP中的JSON数据
      start_index = jsonp.find('(') + 1
      end_index = jsonp.rfind(')')
      json_data = jsonp[start_index:end_index]

      # 解析JSON数据
      data = json.loads(json_data)
      return data

   def get_jsonp_data(url):
      response = requests.get(url)
      jsonp_data = response.text
      data = parse_jsonp(jsonp_data)
      return data
   ```

4. 处理 HTML格式数据（使用bs4模块）

   ```python
   import requests
   from bs4 import BeautifulSoup

   count = 0
   url = "http://www.autohome.com.cn/news/"
   headers = {
      "user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36",
      "referer": "https://www.autohome.com.cn/beijing/",
      "Content-Type": "text/plain;charset=UTF-8"
   }
   res = requests.get(url, headers)
   res.encoding = "gb2312"
   soup = BeautifulSoup(res.text, features="html.parser")
   # print(soup) # 返回解析出来的HTML页面

   # 定位区域
   part_area = soup.find(
      name="div", attrs={"id": "auto-channel-lazyload-article"})

   # 获取所有li标签
   li_list_nodes = part_area.find_all(name="li")
   for li_node in li_list_nodes:
      h3 = li_node.find(name="h3")
      p = li_node.find(name="p")
      img = li_node.find(name="img")
      if not h3:
         continue
      line = "{}\n{}\n{}\n".format(h3.text, p.text, img.attrs["src"])
      print(line)
   ```

5. 获取编辑信息并下载相关图片

   ```python
   import requests
   from bs4 import BeautifulSoup

   count = 0
   url = "http://www.autohome.com.cn/news/"
   headers = {
      "user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36",
      "referer": "https://www.autohome.com.cn/beijing/",
      "Content-Type": "text/plain;charset=UTF-8"
   }
   res = requests.get(url, headers)
   res.encoding = "gb2312"
   soup = BeautifulSoup(res.text, features="html.parser")
   # print(soup) # 返回解析出来的HTML页面

   # 定位区域
   part_area = soup.find(name="ul", attrs={"id": "tagInfo"})

   # 获取所有li标签
   li_list_nodes = part_area.find_all(name="li")
   for li_node in li_list_nodes:
      name = li_node.find(name="div", attrs={
                           "class": "editorname"}).find(name="a")
      img = li_node.find(name="img")
      if not name:
         continue
      img_url = "https:{}".format(img.attrs["src"])
      line = "{}\n{}\n".format(name.text, img_url)
      print(line)
      img = requests.get(url=img_url)
      file_name = "static/{}.jpg".format(name.text)
      with open(file_name, mode="wb") as f:
         f.write(img.content)
   ```

### openpyxl：处理Excel文件

在Python中，openpyxl模块是一个用于操作Excel文件的第三方库。它提供了一组功能强大而易于使用的接口，可以读取和写入Excel文件，并对其中的单元格、行、列、工作表进行操作。
要使用openpyxl模块，首先需要安装它。可以使用pip命令进行安装：`pip install openpyxl`
下面是openpyxl模块中常用的几个函数和方法：

1. `openpyxl.load_workbook(filename, read_only=False, keep_vba=False)`: 用于打开一个Excel文件并返回一个Workbook对象。

   ```python
   import openpyxl

   workbook = openpyxl.load_workbook('example.xlsx')
   ```

2. `workbook.active`: 获取当前活动的工作表（Worksheet）。

3. `workbook.create_sheet(title=None, index=None)`: 创建一个新的工作表，并返回一个Worksheet对象。

4. `worksheet.cell(row=1, column=1)`: 获取指定行列的单元格，并返回一个Cell对象。

5. `worksheet.max_row`: 获取工作表中最大行数。

6. `worksheet.max_column`: 获取工作表中最大列数。

7. `cell.value`: 获取单元格的值。

8. `cell.row`: 获取单元格所在的行号。

9. `cell.column`: 获取单元格所在的列号。

10. `cell.coordinate`: 获取单元格的坐标。

11. `worksheet.iter_rows(min_row=None, max_row=None, min_col=None, max_col=None, values_only=False)`: 迭代工作表中的行，返回一个生成器。

以上这些函数和方法可以用来读取和修改Excel文件中的数据。例如：

```python
import openpyxl

workbook = openpyxl.load_workbook('example.xlsx')
worksheet = workbook.active

# 读取单元格的值
value = worksheet['A1'].value
print(value)

# 修改单元格的值
worksheet['A1'] = 'Hello, World!'

# 保存修改后的文件
workbook.save('example_modified.xlsx')
```

除了上述方法，openpyxl模块还支持一些高级特性，如合并单元格、设置单元格样式、处理公式等。可以根据具体需求查阅官方文档或其他参考资料来学习更多关于openpyxl模块的用法和技巧。

需要注意的是，在使用openpyxl模块操作Excel文件时，应该遵守相关的文件格式规范，并确保对Excel文件的读写行为合法和安全。

#### 读取

##### 加载工作簿

1. 通过文件路径打开文件

   ```python
   import os
   from openpyxl import load_workbook

   base_dir = os.path.dirname(os.path.abspath(__file__))
   file_path = os.path.join(base_dir, 'new.xlsx')

   # 1. 打开Excel文件
   wb = load_workbook(file_path)
   # 2. 获取Excel中的sheet
   print(wb.sheetnames) # ['1_企事业单位负责人', '2_专业技术人员', '3_办事人员和有关人员', '4_社会生产服务和生活服务人员', '备注']
   # 3. 获取单元格
   sheet = wb.worksheets[0]
   cell = sheet.cell(1, 1)
   print(cell.value)
   ```

2. 通过文件对象打开文件

   ```python
   import os
   from openpyxl import load_workbook

   base_dir = os.path.dirname(os.path.abspath(__file__))
   file_path = os.path.join(base_dir, 'new.xlsx')

   # 打开Excel文件
   f = open(file_path, mode="rb")
   wb = load_workbook(f)

   # 获取单元格
   sheet = wb.worksheets[0]
   for row in sheet.iter_rows():
      for cell in row:
         print(cell.value)
   f.close()
   ```

##### 读取单元格

```python
import os
from openpyxl import load_workbook

base_dir = os.path.dirname(os.path.abspath(__file__))
file_path = os.path.join(base_dir, 'new.xlsx')

# 打开Excel文件
wb = load_workbook(file_path)

# 获取每页的（2，3）单元格（一）
for sheet in wb.worksheets:
    # 打印页名
    print(sheet.title)
    cell = sheet.cell(2,3)
    print(cell.value)
# 获取每页的（2，3）单元格（二）
for name in wb.sheetnames:
    sheet = wb[name]
    cell = sheet.cell(2,3)
    print(cell.value)
# 获取每一行
for row_list in sheet.rows:
    text_list = []
    for cell in row_list:
        text_list.append(cell.value)
    print(text_list)
# 获取单元格
sheet = wb.worksheets[0]
# 只获取2-10行的内容
for row in sheet.iter_rows(min_row=2,max_row=10):
    for cell in row:
        print(cell.value)
```

##### 应用1：统计网课观看时长

```python
import os
from openpyxl import load_workbook

base_dir = os.path.dirname(os.path.abspath(__file__))
# 没有源数据无法执行
file_path = os.path.join(base_dir, 'new.xlsx')
wb = load_workbook(file_path)
sheet = wb.worksheets[0]
result = {}

for row_list in sheet.iter_rows(min_row=2):
    # 获取上课人名
    name = row_list[3].value
    # 获取观看时长
    look_time = row_list[7].value
    # 去除后面的“分钟”，转化为数字
    look_time_int = int(look_time[:-2])
    # 如果该观看时长在结果集中就为其增加1人，否则就增加结果中的观看时长数据
    if look_time_int in result:
        result[look_time_int] += 1
    else:
        result[look_time_int] = 1

# 统计观看不同时长直播的人数各有多少
for k in sorted(result.keys()):
    message = "{}有{}人".format(k, result[k])
    print(message)
```

##### 应用2：操作多个工作簿

```python
import os
from openpyxl import load_workbook

# 指定营收报表所在文件夹路径
folder_path = "营收报表"

# 打开营收报表中的所有xlsx文件
for name in os.listdir(folder_path):
    file_path = os.path.join(folder_path, name)
    # 构建文件路径
    print(file_path)
    # 加载xlsx文件
    wb = load_workbook(file_path)
    # 获取第一个工作表
    sheet = wb.worksheets[0]
    # 初始化总和变量
    total = 0
    # 迭代每一行数据（从第二行开始）
    for row_list in sheet.iter_rows(min_row=2):
        # 获取第二列的值，并转换为整数类型
        element = int(row_list[1].value)
        # 将每行第二列的值累加到总和上
        total += element
    # 获取第一行第二列的单元格值（列名）
    header = sheet[1][1].value
    # 拼接文件名、工作表名称、列名和总和为一行数据
    line = "{}-{}-{}-{}".format(name, sheet.title, header, total)
    print(line)
```

##### 应用3：发工资条

```python
from datetime import datetime
from openpyxl import load_workbook
import smtplib
from email.mime.text import MIMEText
from email.utils import formataddr


# 形参：to_mail, subject, content
def send_mail(to_mail, subject, content):
    # 2. 构建邮件内容
    msg = MIMEText(content, "html", "utf-8")  # 内容
    msg["From"] = formataddr(["朱子枫", "zhuzifeng0803@126.com"])  # 自己的名字和邮箱
    msg["to"] = to_mail  # 目标邮箱
    msg["Subject"] = subject  # 主题

    # 3. 发送邮件
    server = smtplib.SMTP_SSL("smtp.126.com")  # 邮箱服务器域名
    server.login("zhuzifeng0803@126.com", "VJTPFIGTUXPFHCCK")  # 账户 授权码
    server.sendmail("zhuzifeng0803@126.com", to_mail, msg.as_string())
    server.quit()


wb = load_workbook("file/工资单.xlsx")
sheet = wb.worksheets[0]

# 1. 获取标题
# ['部门', '姓名', '手机号', '邮箱', '基本工资', '绩效工资', '标准工资', '入离职缺勤', '事假扣除', '病假扣除', '迟到扣款', '应发工资', '五险一金扣除', '计税工资', '应发工资', '实发工资']
header_list = []
# 遍历第一行的每个单元格
for cell in sheet[1]:
   # 将单元格的值添加到标题列表中
    header_list.append(cell.value)

# 2. 获取内容
# 迭代每一行数据，从第二行开始
for row_list in sheet.iter_rows(min_row=2):
    # 获取邮箱地址（第四列）
    email = row_list[3].value
    # 定义空列表，用于存储当前行的字符串形式数据
    row_text_list = []
    # 遍历当前行的每个单元格
    for cell in row_list:
        # 将单元格的值转换为字符串，并添加到行列表中
        row_text_list.append(str(cell.value))
        # 定义空列表，用于存储每个单元格对应的HTML代码
        text_list = []
        # 遍历标题列表的索引和值
        for idx, head in enumerate(header_list):
            # 获取当前列的值
            value = row_text_list[idx]
            # 构建HTML代码行
            line = "<tr><td>{}</td><td>{}</td></tr>".format(head, value)
            # 将HTML代码行添加到列表中
            text_list.append(line)
        # 使用换行符连接HTML代码行
        inner_string = "\n".join(text_list)
        # 构建包含HTML表格的字符串
        data_string = """
    <div style="width: 580px;border: 10px solid #F6F6FC;border-radius: 8px;padding: 20px;">
        <div style="display: flex; justify-content: space-between;margin-top: 10px;">
            <div>百工一道广州有限公司</div>
            <div>{}</div>
        </div>
        <div
            style="font-size: 13px;color:#FFFFFF;line-height: 28px;text-align: center;background: #5D6FED;margin-top: 20px;">
            工资信息</div>
        <div style="border-right: 1px solid #dadada;border-top: 1px solid #dadada;">{}</div>
    </div>
        """.format(datetime.now().strftime("%Y-%m-%d"), inner_string)
        # 调用发送邮件函数，发送工资单邮件
        send_mail(email, "工资单", data_string)
```

##### 应用4：钉钉考勤数据处理

#### 写入

##### 创建新Excel写入

```python
from openpyxl import workbook

wb = workbook.Workbook()
sheet = wb.worksheets[0]
cell = sheet.cell(1, 1)
cell.value = "开始"
wb.save("开始.xlsx")
```

##### 在原Excel修改/追加内容

```python
from openpyxl import load_workbook

wb = load_workbook("开始.xlsx")
sheet = wb.worksheets[0]
cell = sheet.cell(2, 2)
cell.value = "结束"
wb.save("开始.xlsx")
```

##### 可以写入的内容

```python
from openpyxl import load_workbook
from openpyxl.styles import Alignment, Border, Side, Font, PatternFill
from openpyxl.utils.cell import get_column_letter, column_index_from_string


wb = load_workbook("开始.xlsx")
sheet = wb.worksheets[0]
cell = sheet.cell(2, 2)
# 1。 文本
cell.value = "结束"

# 2. 对齐方式
# horizontal = left/center/right
# vertical = top/center/bottom
cell.alignment = Alignment(horizontal="center", vertical="center")

# 3. 边框
cell.border = Border(
    top=Side(style="thin", color="0000CD"),
    bottom=Side(style="thin", color="0000CD"),
    left=Side(style="thin", color="0000CD"),
    right=Side(style="thin", color="0000CD")
)

# 4. 设置字体
cell.font = Font(name="微软雅黑", size=24, color="FF4500")

# 5.背景色
cell.fill = PatternFill("solid",fgColor="FFFC8B")

# 6. 高度和宽度
sheet.row_dimensions[5].height = 200 # 行宽
sheet.column_dimensions["C"].width = 200 # 列高
# idx = column_index_from_string("E")
# print(idx)
# lt = get_column_letter(5)
# print(lt)
# 等效于“C”列高度设为200
sheet.column_dimensions[get_column_letter(3)].width = 200

# 7. 公式
cell.value = "=A1*B2"
cell.value = "=SUM(A2,B2)"

wb.save("开始.xlsx")
```

##### 应用1：下载信息写入Excel

```python
from bs4 import BeautifulSoup
from openpyxl import workbook
from openpyxl.styles import Border, Side, Alignment, PatternFill
from selenium import webdriver
import time

wb = workbook.Workbook()
sheet = wb.worksheets[0]

# 写表头
border = Border(
    top=Side(style="thin", color="0000CD"),
    bottom=Side(style="thin", color="0000CD"),
    left=Side(style="thin", color="0000CD"),
    right=Side(style="thin", color="0000CD")
)
align = Alignment(horizontal="left", vertical="center")
fill = PatternFill('solid', fgColor="FFC125")
header = ["集数", "标题", "时长"]
for col, title in enumerate(header, 1):
    cell = sheet.cell(1, col)
    cell.value = title
    cell.border = border
    cell.alignment = align
    cell.fill = fill

# 列的宽度
sheet.column_dimensions['B'].width = 50
sheet.row_dimensions[1].height = 20

# 获取课程信息
url = "https://www.bilibili.com/video/BV1MG4y1t7nq/?p=16&spm_id_from=pageDriver&vd_source=8d6c89abeaff4fc7eb9a0fe3c3a9ddfc"
# 由于li标签里的数据是用js生成的，这里使用selenium模拟访问来获取数据
driver = webdriver.Chrome()
driver.get(url)
time.sleep(5)
html = driver.page_source
driver.quit()

soup = BeautifulSoup(html, features="html.parser")
li_list_node = soup.find(name="div", attrs={"id": "multi_page"}).find_all(name="div", attrs={"class": "clickitem"})
row_index = 2
for li_node in li_list_node:
    num = li_node.find(name="span", attrs={"class": "page-num"}).text
    title = li_node.find(name="span", attrs={"class": "part"}).text
    duration = li_node.find(name="div", attrs={"class": "duration"}).text

    # 将商品信息写入表格
    data_list = [num, title, duration]
    print(data_list)
    for col, text in enumerate(data_list, 1):
        cell = sheet.cell(row_index, col)
        cell.value = text
        cell.border = border
        cell.alignment = align
    # 设置行高
    sheet.row_dimensions[row_index].height = 18
    row_index += 1

wb.save("courses.xlsx")
```

##### 应用2：用户注册

```python
from openpyxl import load_workbook, workbook
import os

FILE_PATH = 'user_info.xlsx'


def register(user, passwd, mail):
    if os.path.exists(FILE_PATH):
        wb = load_workbook(FILE_PATH)
        sheet = wb.worksheets[0]
        # 定义数据
        row_index = sheet.max_row + 1
        data_list = [user, passwd, mail]
        for col, data in enumerate(data_list, 1):
            cell = sheet.cell(row_index, col)
            cell.value = data
        sheet.row_dimensions[row_index].height = 18
        row_index += 1
    else:
        wb = workbook.Workbook()
        sheet = wb.worksheets[0]
        # 定义表头
        header = ["用户名", "密码", "邮箱"]
        for col, title in enumerate(header, 1):
            cell = sheet.cell(1, col)
            cell.value = title
        # 定义数据
        row_index = 2
        data_list = [user, passwd, mail]
        for col, data in enumerate(data_list, 1):
            cell = sheet.cell(row_index, col)
            cell.value = data
        sheet.row_dimensions[row_index].height = 18
        row_index += 1
    # 保存文件
    wb.save(FILE_PATH)
    return data_list


while True:
    user = input("用户名：")
    if user.upper() == "Q":
        break
    passwd = input("密码：")
    mail = input("邮箱：")
    user_info = register(user, passwd, mail)
    print(user_info)
```

```python
from openpyxl import load_workbook, workbook
import os

FILE_PATH = 'user_info.xlsx'


def get_file_object():
    if os.path.exists(FILE_PATH):
        wb = load_workbook(FILE_PATH)
        sheet = wb.worksheets[0]
        row_index = sheet.max_row + 1
        return wb, sheet, row_index
    wb = workbook.Workbook()
    sheet = wb.worksheets[0]
    row_index = 2
    # 定义表头
    header = ["用户名", "密码", "邮箱"]
    for col, title in enumerate(header, 1):
        cell = sheet.cell(1, col)
        cell.value = title
    return wb, sheet, row_index


def register(user, passwd, mail):
    # 定义数据
    wb, sheet, row_index = get_file_object()
    data_list = [user, passwd, mail]
    for col, data in enumerate(data_list, 1):
        cell = sheet.cell(row_index, col)
        cell.value = data
    sheet.row_dimensions[row_index].height = 18
    row_index += 1
    # 保存文件
    wb.save(FILE_PATH)
    return data_list


def run():
    user = input("用户名：")
    if user.upper() == "Q":
        return "quit"
    passwd = input("密码：")
    mail = input("邮箱：")
    user_info = register(user, passwd, mail)
    print(user_info)


if __name__ == "__main__":
    run()
```

### python-docx：处理word文档

在Python中，python-docx模块是一个用于创建和修改Microsoft Word文档的第三方库。它提供了一组易于使用的接口，可以对Word文档进行内容插入、格式设置、样式操作等操作。
要使用python-docx模块，首先需要安装它。可以使用pip命令进行安装：`pip install python-docx`
下面是python-docx模块中常用的几个类和方法：

1. `docx.Document()`: 创建一个新的Word文档对象。

   ```python
   from docx import Document

   doc = Document()
   ```

2. `document.add_paragraph(text=None, style=None)`: 在文档中添加一个段落，并返回一个Paragraph对象。

3. `document.add_heading(text=None, level=1)`: 在文档中添加一个标题，并返回一个Paragraph对象。

4. `paragraph.text`: 获取或设置段落的文本内容。

5. `paragraph.style`: 获取或设置段落的样式。

6. `paragraph.runs`: 获取段落中的所有Run对象（表示不同格式的文本片段）。

7. `run.text`: 获取或设置Run对象的文本内容。

8. `run.bold`, `run.italic`, `run.underline`, `run.strike`, `run.font.size`, `run.font.name`: 设置Run对象的文本格式。

9. `document.save(filename)`: 保存文档到指定文件。

以上这些类和方法可以用来创建和修改Word文档中的内容。例如：

```python
from docx import Document

# 创建一个新的文档
doc = Document()

# 添加标题和段落
doc.add_heading('Title', level=1)
doc.add_paragraph('This is a paragraph.')

# 设置段落样式
paragraph = doc.paragraphs[1]
paragraph.style = 'Heading 2'

# 添加带格式的文本
run = paragraph.add_run('This is ')
run.bold = True
run.italic = True
run.font.size = Pt(14)
run.font.name = 'Arial'
run = paragraph.add_run('formatted text.')

# 保存文档
doc.save('example.docx')
```

除了上述方法，python-docx模块还支持一些高级特性，如插入图片、表格、页眉页脚、批注等。可以参考官方文档或其他教程来学习更多关于python-docx模块的用法和技巧。

需要注意的是，在使用python-docx模块创建和修改Word文档时，应该遵循相关的文档规范，并确保生成的文档在不同版本和软件中都能正确打开和显示。

1. .docx 文件本质上是一个压缩包：

   1. 文件结构：.docx 文件实际上是由多个文件和文件夹组成的结构。它采用了一种称为“Open Packaging Conventions”的开放标准，将多个文件和文件夹打包在一个单独的压缩文件中。
   2. 压缩格式：.docx 文件使用了标准的ZIP压缩格式，这意味着它可以通过常见的ZIP软件进行解压缩。你可以将 .docx 文件的扩展名改为 .zip，并使用ZIP工具来打开它，然后你将看到其中包含了许多文件和文件夹。
   3. 内容组成：在 .docx 文件解压缩后，你将会看到许多 XML 文件，这些文件描述了文档的内容、样式、布局和元数据等信息。例如，`word/document.xml` 文件包含了文档的实际内容，`word/styles.xml` 文件包含了样式信息，`word/numbering.xml` 文件包含了编号列表的定义等等。此外，还可能包含图像、字体和其他媒体文件等。

2. 使用演示：（无法操作.doc文档）

   ```python
   import docx

   obj = docx.Document("简历.docx")

   # 1. 获取第一个段落对象
   p1 = obj.paragraphs[6]
   print(p1) # 返回对象
   print(p1.text) # 返回文本内容
   print(p1.style.name) # 返回样式名称

   # 2. 获取所有段落的样式及内容
   for p in obj.paragraphs:
      print(p.style.name, p.text)

   # 3. 当一个段落(行)中应用了多个样式时，会被划分为不同的runs
   for ele in p1.runs:
      # ele.bold：是否加粗；ele.font.color.rgb：字体颜色
      print(ele.text, ele.style.name, ele.bold, ele.font.color.rgb)
   ```

3. 支持的样式名称：
   - "Normal" 普通样式，即默认段落样式。
   - "Heading 1", "Heading 2", ... "Heading 9"标题级别样式，用于不同级别的标题。
   - "Title", "Subtitle" 标题和副标题样式。
   - "Body Text" 主体文本样式。
   - "Quote" 引用样式。
   - "Caption" 图片或表格的标题样式。
   - "Hyperlink" 超链接样式。
   - "IntenseQuote": 强调引用样式，通常用于突出显示引用的文本或重要信息。
   - "List", "List2", "List3": 列表样式，用于表示有序或无序列表的项目。这些样式的区别在于其外观和级别的不同，例如缩进或标记符的类型。
   - "ListBullet", "ListBullet2", "ListBullet3": 无序列表项目样式，用于表示无序列表的项目。与 "List" 类似，但使用不同的标记符或符号。
   - "ListContinue", "ListContinue2", "ListContinue3": 续列表样式，用于表示与前一个列表相连接的继续列表项。
   - "ListNumber", "ListNumber2", "ListNumber3": 有序列表项目样式，用于表示有序列表的项目。与 "List" 类似，但使用数字作为标记符。
   - "ListParagraph": 包含在列表中的段落的样式，用于列表中的段落文本。
   - "MacroText": 宏文本样式，用于表示包含宏代码或宏指令的文本。
   - "NoSpacing": 无间距样式，将段落的行间距设置为零，以减少段落之间的空白间隔。
   - "TOCHeading": 目录标题样式，用于表示目录中的标题文本。
   具体的样式名称可能因文档的模板或自定义样式而有所不同。若要获取特定文档中所有样式的名称，可以使用 docx 模块的 `styles` 属性，例如 `obj.styles`，然后遍历该属性以获取所有样式名称。
4. 写入文档：

   ```python
   import docx
   from docx.shared import RGBColor, Pt, Cm
   from docx.enum.text import WD_PARAGRAPH_ALIGNMENT
   from docx.oxml.ns import qn

   obj = docx.Document()
   # 设置标题样式
   title = obj.add_paragraph(text="Hello, World!", style="Title")
   # 1. 设置标题居中对齐
   title.paragraph_format.alignment = WD_PARAGRAPH_ALIGNMENT.CENTER

   obj.add_paragraph(text="问候新世界！", style="Heading 1")
   obj.add_paragraph(text="问候新世界！")

   p = obj.add_paragraph(text="段落测试：")
   # 2. 设置字体大小(会报错，无法直接对段落设置字体大小，而要通过对runs来设置字体大小)
   # p.font.size = Pt(20)
   # 若要对段落设置，用循环遍历段落中的所有文本运行，并设置字体大小
   # for run in p.runs:
   #     run.font.size = Pt(20)

   r1 = p.add_run(text="单元1 ")
   # 3. 设置字体颜色
   r1.font.color.rgb = RGBColor(202, 255, 112)
   # 4. 设置字体大小
   r1.font.size = Pt(20)

   r2 = p.add_run(text="单元2 ")
   # 5. 设置字体加粗
   r2.bold = True
   # 6. 设置字体样式
   r2.font.name = "黑体"

   # 设置中文字体为 "黑体"
   # rpr = r2._element.get_or_add_rPr()
   # rFonts = rpr.get_or_add_rFonts()
   # rFonts.set(qn('w:eastAsia'), '黑体')
   # 设置中文字体为 "黑体"（2）
   r2._element.get_or_add_rPr().get_or_add_rFonts().set(qn('w:eastAsia'), '黑体')

   p.add_run(text="单元3")

   # 7. 设置行间距
   p1 = obj.add_paragraph(text="问候新世界问候新世界问候新世界问候新世界问候新世界问候新世界问候新世界问候新世界问候新世界问候新世界问候新世界问候新世界问候新世界问候新世界问候新世界问候新世界问候新世界问候新世界问候新世界问候新世界问候新世界问候新世界")
   p.paragraph_format.line_spacing = 1.5

   # 8. 插入图片
   p2 = obj.add_paragraph()
   r3 = p2.add_run()
   r3.add_picture("Ali.png", width=Cm(5))
   p2.paragraph_format.alignment = WD_PARAGRAPH_ALIGNMENT.CENTER

   # 如果文件已打开，保存会报错
   obj.save("news.docx")
   ```

5. 应用：批量生成审批报告

   ```python
   import docx
   from docx.shared import RGBColor, Pt, Cm
   from docx.enum.text import WD_PARAGRAPH_ALIGNMENT
   from docx.oxml.ns import qn

   user_list = ["张三", "李四", "王五"]

   for name in user_list:
      document = docx.Document()
      # 设置正文字体
      for paragraph in document.paragraphs:
         for run in paragraph.runs:
               run.font.name = "黑体"
               run.font.size = Pt(14)
               run._element.get_or_add_rPr().get_or_add_rFonts().set(qn('w:eastAsia'), '黑体')

      # LOGO
      logo_area = document.add_paragraph()
      r1 = logo_area.add_run()
      r1.add_picture("Ali.png", width=Cm(5))
      logo_area.paragraph_format.alignment = WD_PARAGRAPH_ALIGNMENT.CENTER

      # 标题
      p2 = document.add_paragraph() # 初始化一个自然段
      p2.alignment = WD_PARAGRAPH_ALIGNMENT.CENTER
      r2 = p2.add_run("审批报告说明")
      r2.font.name = u"微软雅黑" # 设置西文字体
      r2._element.get_or_add_rPr().get_or_add_rFonts().set(qn('w:eastAsia'), '黑体') # 设置中文字体
      r2.font.size = Pt(21)
      r2.font.bold = True

      p3 = document.add_paragraph()
      r3 = p3.add_run("尊敬的{}".format(name))
      r3.font.name = u"微软雅黑" # 设置西文字体
      r3._element.get_or_add_rPr().get_or_add_rFonts().set(qn('w:eastAsia'), '黑体') # 设置中文字体
      r3.font.size = Pt(16)
      r3.font.bold = True
      r3.font.color.rgb = RGBColor(202, 255, 112)

      document.save("{}.docx".format(name))
   ```

## 模块总结

1. 模块的分类：
   1. 自定义模块:
      1. os.path，导入模块时python内部都会去那个目录找；
      2. 自己写py文件时，不要与python内置模块同名；
      3. import xx form xx; import xx
   2. 内置模块：time/datetime/json/re/random/os...
   3. 第三方模块：requests/openpyxl/python-docx/flask/bs4
2. 查看当前目录下所有的文件：`os.listdir` 获取一级目录下的文件/`os.walk` 获取所有目录下的文件
3. 时间模块：时间戳/datetime格式/字符串，三种时间格式可以互相转化。
4. JSON模块：
   1. JSON本质是字符串，有一些自己的格式要求，例如：无元组，无单引号；
   2. `json.dumps`序列化时，只能序列化python常用的数据类型(python: JSON)：
       - dict: object;
       - list, tuple: array;
       - str: string;
       - int, float: number;
       - True: true;
       - False: false;
       - None: null
5. re正则模块：
   - \d \w
   - 贪婪匹配（默认）和非贪婪匹配（+?）
   - re.search/re.match/re.findall
6. 第三方模块
   1. pip管理工具
   2. 源码
   3. wheel包
